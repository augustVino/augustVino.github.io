<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>总结一下 ES6 常用知识点 | Vino&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/img/logo_desktop_ico.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/img/logo_desktop_ico.png">
    <meta name="description" content="前端爬坑之旅">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    <link rel="preload" href="/assets/css/0.styles.e2aafa94.css" as="style"><link rel="preload" href="/assets/js/app.6a883236.js" as="script"><link rel="preload" href="/assets/js/2.9374ea52.js" as="script"><link rel="preload" href="/assets/js/92.d467060e.js" as="script"><link rel="preload" href="/assets/js/37.c1852146.js" as="script"><link rel="preload" href="/assets/js/40.c8e1b6f3.js" as="script"><link rel="preload" href="/assets/js/11.c968a7c6.js" as="script"><link rel="preload" href="/assets/js/10.832e2843.js" as="script"><link rel="prefetch" href="/assets/js/100.a77dd05d.js"><link rel="prefetch" href="/assets/js/101.73c0a4ce.js"><link rel="prefetch" href="/assets/js/102.9ae8ed71.js"><link rel="prefetch" href="/assets/js/103.12561fe9.js"><link rel="prefetch" href="/assets/js/104.bec8e2c8.js"><link rel="prefetch" href="/assets/js/105.84cc1c77.js"><link rel="prefetch" href="/assets/js/106.3f8b202c.js"><link rel="prefetch" href="/assets/js/107.37d1f20e.js"><link rel="prefetch" href="/assets/js/108.4300c29e.js"><link rel="prefetch" href="/assets/js/109.c5b5ea31.js"><link rel="prefetch" href="/assets/js/110.6256e819.js"><link rel="prefetch" href="/assets/js/111.f3bed9b7.js"><link rel="prefetch" href="/assets/js/112.db3075af.js"><link rel="prefetch" href="/assets/js/113.b1a2bcee.js"><link rel="prefetch" href="/assets/js/114.a7af67ef.js"><link rel="prefetch" href="/assets/js/115.1aec54a4.js"><link rel="prefetch" href="/assets/js/116.bf8a8c99.js"><link rel="prefetch" href="/assets/js/117.9036cf29.js"><link rel="prefetch" href="/assets/js/118.526a918f.js"><link rel="prefetch" href="/assets/js/119.1b31bef6.js"><link rel="prefetch" href="/assets/js/12.8e946eb4.js"><link rel="prefetch" href="/assets/js/120.c419da80.js"><link rel="prefetch" href="/assets/js/121.0b66c6f9.js"><link rel="prefetch" href="/assets/js/122.27c5c6a4.js"><link rel="prefetch" href="/assets/js/123.daaaf41c.js"><link rel="prefetch" href="/assets/js/124.d4b9000e.js"><link rel="prefetch" href="/assets/js/125.053f3bc0.js"><link rel="prefetch" href="/assets/js/126.d540e42e.js"><link rel="prefetch" href="/assets/js/127.e93ae496.js"><link rel="prefetch" href="/assets/js/128.d0a8dcf6.js"><link rel="prefetch" href="/assets/js/129.462abe68.js"><link rel="prefetch" href="/assets/js/13.eba7a0f8.js"><link rel="prefetch" href="/assets/js/130.4769bd2f.js"><link rel="prefetch" href="/assets/js/131.d5b31911.js"><link rel="prefetch" href="/assets/js/132.acc7040a.js"><link rel="prefetch" href="/assets/js/133.71933ed3.js"><link rel="prefetch" href="/assets/js/134.bd38bf43.js"><link rel="prefetch" href="/assets/js/135.bad5b011.js"><link rel="prefetch" href="/assets/js/136.555d3bd2.js"><link rel="prefetch" href="/assets/js/137.6537e4ea.js"><link rel="prefetch" href="/assets/js/138.ce213003.js"><link rel="prefetch" href="/assets/js/139.c18da3bb.js"><link rel="prefetch" href="/assets/js/14.7e00c282.js"><link rel="prefetch" href="/assets/js/140.539f3db1.js"><link rel="prefetch" href="/assets/js/15.749d7854.js"><link rel="prefetch" href="/assets/js/16.e815d63f.js"><link rel="prefetch" href="/assets/js/17.67b20db3.js"><link rel="prefetch" href="/assets/js/18.0b154c9b.js"><link rel="prefetch" href="/assets/js/19.04e82b4c.js"><link rel="prefetch" href="/assets/js/20.6c871bbe.js"><link rel="prefetch" href="/assets/js/21.040cfd9f.js"><link rel="prefetch" href="/assets/js/22.ba06fe8a.js"><link rel="prefetch" href="/assets/js/23.659cd4a3.js"><link rel="prefetch" href="/assets/js/24.0ee4737d.js"><link rel="prefetch" href="/assets/js/25.c6e6b0c1.js"><link rel="prefetch" href="/assets/js/26.31505d35.js"><link rel="prefetch" href="/assets/js/27.8d43c162.js"><link rel="prefetch" href="/assets/js/28.a6118c14.js"><link rel="prefetch" href="/assets/js/29.7e2f4b2e.js"><link rel="prefetch" href="/assets/js/3.8eff0f5c.js"><link rel="prefetch" href="/assets/js/30.4e2fbafe.js"><link rel="prefetch" href="/assets/js/31.39ee6447.js"><link rel="prefetch" href="/assets/js/32.51b21fd8.js"><link rel="prefetch" href="/assets/js/33.ee7a2d0d.js"><link rel="prefetch" href="/assets/js/34.9c200580.js"><link rel="prefetch" href="/assets/js/35.3143ab4d.js"><link rel="prefetch" href="/assets/js/36.ea6f63b6.js"><link rel="prefetch" href="/assets/js/38.bc0a4a86.js"><link rel="prefetch" href="/assets/js/39.06c223ea.js"><link rel="prefetch" href="/assets/js/4.f4c73307.js"><link rel="prefetch" href="/assets/js/41.a7f1a166.js"><link rel="prefetch" href="/assets/js/42.f18fd12e.js"><link rel="prefetch" href="/assets/js/43.fc98e253.js"><link rel="prefetch" href="/assets/js/44.b2c07c67.js"><link rel="prefetch" href="/assets/js/45.4fc13d73.js"><link rel="prefetch" href="/assets/js/46.65529072.js"><link rel="prefetch" href="/assets/js/47.dc68f044.js"><link rel="prefetch" href="/assets/js/48.6cf203cb.js"><link rel="prefetch" href="/assets/js/49.cf13277f.js"><link rel="prefetch" href="/assets/js/5.899c2ebf.js"><link rel="prefetch" href="/assets/js/50.3c8a9011.js"><link rel="prefetch" href="/assets/js/51.30f0429e.js"><link rel="prefetch" href="/assets/js/52.4d5b5582.js"><link rel="prefetch" href="/assets/js/53.553b1f42.js"><link rel="prefetch" href="/assets/js/54.39c781cd.js"><link rel="prefetch" href="/assets/js/55.dc5cc4c3.js"><link rel="prefetch" href="/assets/js/56.107a1be5.js"><link rel="prefetch" href="/assets/js/57.739995c4.js"><link rel="prefetch" href="/assets/js/58.7bb19fe1.js"><link rel="prefetch" href="/assets/js/59.d7c13ae9.js"><link rel="prefetch" href="/assets/js/6.41d8e581.js"><link rel="prefetch" href="/assets/js/60.dc54e6ca.js"><link rel="prefetch" href="/assets/js/61.1fcaa212.js"><link rel="prefetch" href="/assets/js/62.9b9cd2b0.js"><link rel="prefetch" href="/assets/js/63.658465ff.js"><link rel="prefetch" href="/assets/js/64.2298e1b5.js"><link rel="prefetch" href="/assets/js/65.49904e03.js"><link rel="prefetch" href="/assets/js/66.99608c3b.js"><link rel="prefetch" href="/assets/js/67.555838e5.js"><link rel="prefetch" href="/assets/js/68.7a4f68e2.js"><link rel="prefetch" href="/assets/js/69.c82901c0.js"><link rel="prefetch" href="/assets/js/7.fafe71d6.js"><link rel="prefetch" href="/assets/js/70.49c51f86.js"><link rel="prefetch" href="/assets/js/71.2b9d0b92.js"><link rel="prefetch" href="/assets/js/72.0eeeea1e.js"><link rel="prefetch" href="/assets/js/73.c3f3b41c.js"><link rel="prefetch" href="/assets/js/74.8c248c25.js"><link rel="prefetch" href="/assets/js/75.a7176969.js"><link rel="prefetch" href="/assets/js/76.13f4003f.js"><link rel="prefetch" href="/assets/js/77.b8253305.js"><link rel="prefetch" href="/assets/js/78.c44b2cfb.js"><link rel="prefetch" href="/assets/js/79.630a29b6.js"><link rel="prefetch" href="/assets/js/8.5ba1a544.js"><link rel="prefetch" href="/assets/js/80.8eb14479.js"><link rel="prefetch" href="/assets/js/81.3329c4ab.js"><link rel="prefetch" href="/assets/js/82.01725451.js"><link rel="prefetch" href="/assets/js/83.69c350b2.js"><link rel="prefetch" href="/assets/js/84.77515121.js"><link rel="prefetch" href="/assets/js/85.f14f041b.js"><link rel="prefetch" href="/assets/js/86.f4a52367.js"><link rel="prefetch" href="/assets/js/87.5257ee16.js"><link rel="prefetch" href="/assets/js/88.39417064.js"><link rel="prefetch" href="/assets/js/89.2a4e761d.js"><link rel="prefetch" href="/assets/js/9.1b88acc2.js"><link rel="prefetch" href="/assets/js/90.03545ab7.js"><link rel="prefetch" href="/assets/js/91.c7a9c2a1.js"><link rel="prefetch" href="/assets/js/93.9a718b4d.js"><link rel="prefetch" href="/assets/js/94.b59c0ce5.js"><link rel="prefetch" href="/assets/js/95.c506ff9a.js"><link rel="prefetch" href="/assets/js/96.3d015acc.js"><link rel="prefetch" href="/assets/js/97.ddfc6d29.js"><link rel="prefetch" href="/assets/js/98.7dc27d73.js"><link rel="prefetch" href="/assets/js/99.6643cb5d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e2aafa94.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo_circle.png" alt="Vino's Blog" class="logo"> <span class="site-name can-hide">Vino's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/Blog/" class="nav-link">
  进阶·博文
</a></div><div class="nav-item"><a href="/FrontEnd/" class="nav-link router-link-active">
  爬坑·总结
</a></div><div class="nav-item"><a href="/Life/" class="nav-link">
  Music·生活
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Contact" class="dropdown-title"><span class="title">Contact</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/augustVino/augustVino.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://weibo.com/neikeda/profile" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Weibo
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/Blog/" class="nav-link">
  进阶·博文
</a></div><div class="nav-item"><a href="/FrontEnd/" class="nav-link router-link-active">
  爬坑·总结
</a></div><div class="nav-item"><a href="/Life/" class="nav-link">
  Music·生活
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Contact" class="dropdown-title"><span class="title">Contact</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/augustVino/augustVino.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://weibo.com/neikeda/profile" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Weibo
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具·相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FrontEnd/JavaScript/2.1.html" class="active sidebar-link">总结一下 ES6 常用知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#修正" class="sidebar-link">修正</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#es2015" class="sidebar-link">ES2015</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#声明" class="sidebar-link">声明</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#解构赋值" class="sidebar-link">解构赋值</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#字符串扩展" class="sidebar-link">字符串扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#数值扩展" class="sidebar-link">数值扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#对象扩展" class="sidebar-link">对象扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#数组扩展" class="sidebar-link">数组扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#函数扩展" class="sidebar-link">函数扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#正则扩展" class="sidebar-link">正则扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#symbol" class="sidebar-link">Symbol</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#set" class="sidebar-link">Set</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#map" class="sidebar-link">Map</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#proxy" class="sidebar-link">Proxy</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#reflect" class="sidebar-link">Reflect</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#class" class="sidebar-link">Class</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#module" class="sidebar-link">Module</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#iterator" class="sidebar-link">Iterator</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#promise" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#generator" class="sidebar-link">Generator</a></li></ul></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#es2016" class="sidebar-link">ES2016</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#数值扩展-2" class="sidebar-link">数值扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#数组扩展-2" class="sidebar-link">数组扩展</a></li></ul></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#es2017" class="sidebar-link">ES2017</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#声明-2" class="sidebar-link">声明</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#字符串扩展-2" class="sidebar-link">字符串扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#对象扩展-2" class="sidebar-link">对象扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#函数扩展-2" class="sidebar-link">函数扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#async" class="sidebar-link">Async</a></li></ul></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#es2018" class="sidebar-link">ES2018</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#字符串扩展-3" class="sidebar-link">字符串扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#对象扩展-3" class="sidebar-link">对象扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#正则扩展-2" class="sidebar-link">正则扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#promise-2" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#async-2" class="sidebar-link">Async</a></li></ul></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#es2019" class="sidebar-link">ES2019</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#字符串扩展-4" class="sidebar-link">字符串扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#对象扩展-4" class="sidebar-link">对象扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#数组扩展-3" class="sidebar-link">数组扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#函数扩展-3" class="sidebar-link">函数扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#symbol-2" class="sidebar-link">Symbol</a></li></ul></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#es提案" class="sidebar-link">ES提案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#声明-3" class="sidebar-link">声明</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#数值扩展-3" class="sidebar-link">数值扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#对象扩展-5" class="sidebar-link">对象扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#函数扩展-4" class="sidebar-link">函数扩展</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#proxy-2" class="sidebar-link">Proxy</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#realm" class="sidebar-link">Realm</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#class-2" class="sidebar-link">Class</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#module-2" class="sidebar-link">Module</a></li><li class="sidebar-sub-header"><a href="/FrontEnd/JavaScript/2.1.html#async-3" class="sidebar-link">Async</a></li></ul></li></ul></li><li><a href="/FrontEnd/JavaScript/2.2.html" class="sidebar-link">防止按钮在短时间内重复点击</a></li><li><a href="/FrontEnd/JavaScript/2.3.html" class="sidebar-link">JavaScript类数组对象NodeList</a></li><li><a href="/FrontEnd/JavaScript/2.4.html" class="sidebar-link">Web Notification</a></li><li><a href="/FrontEnd/JavaScript/2.5.html" class="sidebar-link">JS 数组知识点</a></li><li><a href="/FrontEnd/JavaScript/2.6.html" class="sidebar-link">类数组的 push</a></li><li><a href="/FrontEnd/JavaScript/2.7.html" class="sidebar-link">实现一个sleep函数</a></li><li><a href="/FrontEnd/JavaScript/2.8.html" class="sidebar-link">实现简单的Event模块的emit和on方法</a></li><li><a href="/FrontEnd/JavaScript/2.9.html" class="sidebar-link">实现简单的Promise</a></li><li><a href="/FrontEnd/JavaScript/2.10.html" class="sidebar-link">H5页面中长按保存图片</a></li><li><a href="/FrontEnd/JavaScript/2.11.1.html" class="sidebar-link">JS 中常用的距离总结（上）</a></li><li><a href="/FrontEnd/JavaScript/2.11.2.html" class="sidebar-link">JS 中常用的距离总结（下）</a></li><li><a href="/FrontEnd/JavaScript/2.12.html" class="sidebar-link">h5 图片验证码</a></li><li><a href="/FrontEnd/JavaScript/2.13.html" class="sidebar-link">JS 数据结构--链表</a></li><li><a href="/FrontEnd/JavaScript/2.14.html" class="sidebar-link">JS技巧(工具)函数</a></li><li><a href="/FrontEnd/JavaScript/2.15.html" class="sidebar-link">JavaScript方法的重写</a></li><li><a href="/FrontEnd/JavaScript/2.16.html" class="sidebar-link">IntersectionObserver 实现图片懒加载</a></li><li><a href="/FrontEnd/JavaScript/2.17.html" class="sidebar-link">audio、video标签在各端的自动播放</a></li><li><a href="/FrontEnd/JavaScript/2.18.html" class="sidebar-link">如何解决异步请求的竞态问题</a></li><li><a href="/FrontEnd/JavaScript/2.19.html" class="sidebar-link">事件对象 event 中的 target 和 currentTarget</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Image</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>业余·折腾</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>支付·相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法·相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试·相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FrontEnd/Interview/8.1.html" class="sidebar-link">HTTP系列</a></li><li><a href="/FrontEnd/Interview/8.2.html" class="sidebar-link">JavaScript - 45道 Promise 题</a></li><li><a href="/FrontEnd/Interview/8.3.html" class="sidebar-link">JavaScript - 40道 this 题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="总结一下-es6-常用知识点"><a href="#总结一下-es6-常用知识点" class="header-anchor">#</a> 总结一下 ES6 常用知识点</h1> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>引用于掘金前端大神JowayYoung的<a href="https://juejin.im/post/5d9bf530518825427b27639d#heading-0" target="_blank" rel="noopener noreferrer">文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></div> <div class="img-box"><img src="/img/javascript2.1-1" alt=""> <!----></div> <h2 id="修正"><a href="#修正" class="header-anchor">#</a> 修正</h2> <p><code>ES6</code>是<code>ECMA</code>为<code>JavaScript</code>制定的第6个标准版本。</p> <p>标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。<code>ECMAscript 2015</code>是在2015年6月发布ES6的第一个版本。以此类推，<code>ECMAscript 2016</code>是ES6的第二个版本、 <code>ECMAscript 2017</code>是ES6的第三个版本。<strong>ES6</strong>既是一个历史名词也是一个泛指，含义是<code>5.1版本</code>以后的<code>JavaScript下一代标准</code>，目前涵盖了<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>。</p> <p>所以有些文章上提到的<code>ES7</code>(实质上是<code>ES2016</code>)、<code>ES8</code>(实质上是<code>ES2017</code>)、<code>ES9</code>(实质上是<code>ES2018</code>)、<code>ES10</code>(实质上是<code>ES2019</code>)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了<strong>ES2015</strong>(ES6.0)、<strong>ES2016</strong>(ES6.1)、<strong>ES2017</strong>(ES6.2)、<strong>ES2018</strong>(ES6.3)、<strong>ES2019</strong>(ES6.4)。
<div class="img-box"><img src="/img/javascript2.1-2" alt=""> <!----></div>
另外，ES6更新的内容主要分为以下几点</p> <ul><li><strong>表达式</strong>：声明、解构赋值</li> <li><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li> <li><strong>语句与运算</strong>：Class、Module、Iterator</li> <li><strong>异步编程</strong>：Promise、Generator、Async</li></ul> <h2 id="es2015"><a href="#es2015" class="header-anchor">#</a> ES2015</h2> <div class="img-box"><img src="/img/javascript2.1-3" alt=""> <!----></div> <h3 id="声明"><a href="#声明" class="header-anchor">#</a> 声明</h3> <ul><li><strong>const命令</strong>：声明常量</li> <li><strong>let命令</strong>：声明变量</li></ul> <h4 id="const与let的不同点在于："><a href="#const与let的不同点在于：" class="header-anchor">#</a> <code>const</code>与<code>let</code>的不同点在于：</h4> <ol><li><code>const</code>如果声明的变量是简单的值，则不能改变变量的值，修改会报错；</li> <li><code>const</code>如果声明的是复合类型的变量，则只保证变量地址不变，值可以变；</li> <li><code>JavaScript</code> 编辑器对<code>const</code>的优化要比<code>let</code>好，多使用<code>const</code>有利于提高程序的运行效率；</li> <li>更好的代码语义化，一眼看到就是常量。</li> <li>赋值使用：<code>const</code>声明常量后必须立马赋值；<code>let</code>声明变量后可立马赋值或使用时赋值</li></ol> <h4 id="注意点"><a href="#注意点" class="header-anchor">#</a> 注意点</h4> <ol><li>不允许重复声明</li> <li>未定义就使用会报错：<code>const</code>和<code>let</code>不存在变量提升</li> <li>暂时性死区：只要块级作用域内存在<code>const</code>和<code>let</code>，所声明常量和变量就绑定此区域，不再受外部影响</li></ol> <h4 id="用let来代替var"><a href="#用let来代替var" class="header-anchor">#</a> 用let来代替var</h4> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">/*demo1--var*/</span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10</span>
	arr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10</span>
	arr<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10</span>
	arr<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10</span>
	
	<span class="token comment">/*demo1--let*/</span>
	<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5</span>
	arr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6</span>
	arr<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8</span>
	arr<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//9</span>
	
	<span class="token comment">/*demo2--var*/</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//结果：5,5,5,5,5</span>
	<span class="token comment">//并不是0，1，2，3，4 ！！！原因就在于，var i=0，定义的不是局部变量，而是全局变量，这里不会形成闭包。</span>

	<span class="token comment">/*demo2--let*/</span>
	<span class="token string">&quot;use strict&quot;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//结果：0,1,2,3,4</span>
	<span class="token comment">//并不是打印25次！！！原因还是因为，像for循环的大括号，是不会形成作用域的。</span>
	
	<span class="token comment">/*demo3--var*/</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>  
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//结果：25次</span>
	<span class="token comment">//0 1 2 3 4 0 1 2 3 4 ... 0 1 2 3 4</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706526-40788">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    /*demo1--var*/
    var arr = [];
    for( var i = 0; i &lt; 10; i++){
	    arr[i] = function(){
			console.log(i);
		}
	};
	arr[5]();//10
	arr[6]();//10
	arr[8]();//10
	arr[9]();//10
	
	/*demo1--let*/
	var arr = [];
    for( let i = 0; i &lt; 10; i++){
	    arr[i] = function(){
			console.log(i);
		}
	};
	arr[5]();//5
	arr[6]();//6
	arr[8]();//8
	arr[9]();//9
	
	/*demo2--var*/
	for(var i=0; i&lt;5; i++){
	    setTimeout(function(){
            alert(i); 
	    },1000);
	};
	//结果：5,5,5,5,5
	//并不是0，1，2，3，4 ！！！原因就在于，var i=0，定义的不是局部变量，而是全局变量，这里不会形成闭包。

	/*demo2--let*/
	&quot;use strict&quot;
	for(let i = 0; i &lt; 5; i++){
	    setTimeout(function(){
            alert(i); 
	    },1000);
	};
	//结果：0,1,2,3,4
	//并不是打印25次！！！原因还是因为，像for循环的大括号，是不会形成作用域的。
	
	/*demo3--var*/
	for(let i = 0; i &lt; 5; i++){
	    for(let i = 0; i &lt; 5; i++){
	        console.log(i);
	    }  
	};
	//结果：25次
	//0 1 2 3 4 0 1 2 3 4 ... 0 1 2 3 4
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706526-40788" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706526-23166">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    /*demo1--var*/
    var arr = [];
    for( var i = 0; i &lt; 10; i++){
	    arr[i] = function(){
			console.log(i);
		}
	};
	arr[5]();//10
	arr[6]();//10
	arr[8]();//10
	arr[9]();//10
	
	/*demo1--let*/
	var arr = [];
    for( let i = 0; i &lt; 10; i++){
	    arr[i] = function(){
			console.log(i);
		}
	};
	arr[5]();//5
	arr[6]();//6
	arr[8]();//8
	arr[9]();//9
	
	/*demo2--var*/
	for(var i=0; i&lt;5; i++){
	    setTimeout(function(){
            alert(i); 
	    },1000);
	};
	//结果：5,5,5,5,5
	//并不是0，1，2，3，4 ！！！原因就在于，var i=0，定义的不是局部变量，而是全局变量，这里不会形成闭包。

	/*demo2--let*/
	&quot;use strict&quot;
	for(let i = 0; i &lt; 5; i++){
	    setTimeout(function(){
            alert(i); 
	    },1000);
	};
	//结果：0,1,2,3,4
	//并不是打印25次！！！原因还是因为，像for循环的大括号，是不会形成作用域的。
	
	/*demo3--var*/
	for(let i = 0; i &lt; 5; i++){
	    for(let i = 0; i &lt; 5; i++){
	        console.log(i);
	    }  
	};
	//结果：25次
	//0 1 2 3 4 0 1 2 3 4 ... 0 1 2 3 4
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706526-23166" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><p><strong>var</strong>声明的变量作用域不是块级的，会扩大变量的作用域，可能造成不必要的shadow（变量覆盖），通常情况下都不是想要的结果。<strong>let</strong>声明的变量作用域就更加的精确，离开作用域变量就销毁。
在ES6中还有个<strong>const</strong>常量，不可以被更改，所以声明变量的时候（尤其是全局变量时）尽量使用<strong>const</strong>。</p> <blockquote><p><strong>建议</strong>：所有的函数都应该设置为常量。</p></blockquote> <p><strong>let</strong>和<strong>var</strong>关键字的异同:</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">/*声明后未赋值，两者的表现相同*/</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token keyword">var</span> varTest<span class="token punctuation">;</span>
	    <span class="token keyword">let</span> letTest<span class="token punctuation">;</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>varTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出undefined</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>letTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出undefined</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*使用未声明的变量，表现不同*/</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>varTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出undefined(注意要注释掉下面一行才能运行)</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>letTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//直接报错：ReferenceError: letTest is not defined</span>
	    <span class="token keyword">var</span> varTest <span class="token operator">=</span> <span class="token string">'test var OK.'</span><span class="token punctuation">;</span>
	    <span class="token keyword">let</span> letTest <span class="token operator">=</span> <span class="token string">'test let OK.'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*重复声明同一个变量时，表现不同*/</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token keyword">var</span> varTest <span class="token operator">=</span> <span class="token string">'test var OK.'</span><span class="token punctuation">;</span>
	    <span class="token keyword">let</span> letTest <span class="token operator">=</span> <span class="token string">'test let OK.'</span><span class="token punctuation">;</span>
	    <span class="token keyword">var</span> varTest <span class="token operator">=</span> <span class="token string">'varTest changed.'</span><span class="token punctuation">;</span>
	    <span class="token keyword">let</span> letTest <span class="token operator">=</span> <span class="token string">'letTest changed.'</span><span class="token punctuation">;</span> <span class="token comment">//直接报错：SyntaxError: Identifier 'letTest' has already been declared</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>varTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>letTest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*变量作用范围，表现不同*/</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token keyword">var</span> varTest <span class="token operator">=</span> <span class="token string">'test var OK.'</span><span class="token punctuation">;</span>
	    <span class="token keyword">let</span> letTest <span class="token operator">=</span> <span class="token string">'test let OK.'</span><span class="token punctuation">;</span>
	    <span class="token punctuation">{</span>
		    <span class="token keyword">var</span> varTest <span class="token operator">=</span> <span class="token string">'varTest changed.'</span><span class="token punctuation">;</span>
		    <span class="token keyword">let</span> letTest <span class="token operator">=</span> <span class="token string">'letTest changed.'</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>varTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出&quot;varTest changed.&quot;，内部&quot;{}&quot;中声明的varTest变量覆盖外部的letTest声明</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>letTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出&quot;test let OK.&quot;，内部&quot;{}&quot;中声明的letTest和外部的letTest不是同一个变量</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706527-91458">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    /*声明后未赋值，两者的表现相同*/
    (function() {
	    var varTest;
	    let letTest;
	    console.log(varTest); //输出undefined
	    console.log(letTest); //输出undefined
    }());

	/*使用未声明的变量，表现不同*/
    (function() {
	    console.log(varTest); //输出undefined(注意要注释掉下面一行才能运行)
	    console.log(letTest); //直接报错：ReferenceError: letTest is not defined
	    var varTest = 'test var OK.';
	    let letTest = 'test let OK.';
    }());

	/*重复声明同一个变量时，表现不同*/
    (function() {
	    var varTest = 'test var OK.';
	    let letTest = 'test let OK.';
	    var varTest = 'varTest changed.';
	    let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared
	    console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)
	    console.log(letTest);
    }());

	/*变量作用范围，表现不同*/
    (function() {
	    var varTest = 'test var OK.';
	    let letTest = 'test let OK.';
	    {
		    var varTest = 'varTest changed.';
		    let letTest = 'letTest changed.';
	    }
	    console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;{}&quot;中声明的varTest变量覆盖外部的letTest声明
	    console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;{}&quot;中声明的letTest和外部的letTest不是同一个变量
    }());
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706527-91458" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706527-63434">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    /*声明后未赋值，两者的表现相同*/
    (function() {
	    var varTest;
	    let letTest;
	    console.log(varTest); //输出undefined
	    console.log(letTest); //输出undefined
    }());

	/*使用未声明的变量，表现不同*/
    (function() {
	    console.log(varTest); //输出undefined(注意要注释掉下面一行才能运行)
	    console.log(letTest); //直接报错：ReferenceError: letTest is not defined
	    var varTest = 'test var OK.';
	    let letTest = 'test let OK.';
    }());

	/*重复声明同一个变量时，表现不同*/
    (function() {
	    var varTest = 'test var OK.';
	    let letTest = 'test let OK.';
	    var varTest = 'varTest changed.';
	    let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared
	    console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)
	    console.log(letTest);
    }());

	/*变量作用范围，表现不同*/
    (function() {
	    var varTest = 'test var OK.';
	    let letTest = 'test let OK.';
	    {
		    var varTest = 'varTest changed.';
		    let letTest = 'letTest changed.';
	    }
	    console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;{}&quot;中声明的varTest变量覆盖外部的letTest声明
	    console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;{}&quot;中声明的letTest和外部的letTest不是同一个变量
    }());
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706527-63434" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><blockquote><p><strong>注意</strong>：“javascript 严格模式”  <strong>'use strict';</strong></p></blockquote> <h3 id="解构赋值"><a href="#解构赋值" class="header-anchor">#</a> 解构赋值</h3> <ul><li><p>字符串解构：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></p></li> <li><p>数值解构：<code>const { toString: s } = 123</code></p></li> <li><p>布尔值解构：<code>const { toString: b } = true</code></p></li> <li><p>对象解构</p> <ul><li>形式：<code>const { x, y } = { x: 1, y: 2 }</code></li> <li>默认：<code>const { x, y = 2 } = { x: 1 }</code></li> <li>改名：<code>const { x, y: z } = { x: 1, y: 2 }</code></li></ul></li> <li><p>数组解构</p> <ul><li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li> <li>形式：<code>const [x, y] = [1, 2]</code></li> <li>默认：<code>const [x, y = 2] = [1]</code></li></ul></li> <li><p>函数参数解构</p> <ul><li>数组解构：<code>function Func([x = 0, y = 1]) {}</code></li> <li>对象解构：<code>function Func({ x = 0, y = 1 } = {}) {}</code></li></ul></li></ul> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <ul><li>交换变量值：<code>[x, y] = [y, x]</code></li> <li>返回函数多个值：<code>const [x, y, z] = Func()</code></li> <li>定义函数参数：<code>Func([1, 2])</code></li> <li>提取JSON数据：<code>const { name, version } = packageJson</code></li> <li>定义函数参数默认值：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li> <li>遍历Map结构：<code>for (let [k, v] of Map) {}</code></li> <li>输入模块指定属性和方法：<code>const { readFile, writeFile } = require(&quot;fs&quot;)</code></li></ul> <h4 id="重点难点"><a href="#重点难点" class="header-anchor">#</a> 重点难点</h4> <ul><li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li> <li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li> <li>解构默认值生效条件：属性值严格等于<code>undefined</code></li> <li>解构遵循匹配模式</li> <li>解构不成功时变量的值等于<code>undefined</code></li> <li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li></ul> <h3 id="字符串扩展"><a href="#字符串扩展" class="header-anchor">#</a> 字符串扩展</h3> <ul><li><strong>Unicode表示法</strong>：<code>大括号包含</code>表示Unicode字符(<code>\u{0xXX}</code>或<code>\u{0XXX}</code>)</li> <li><strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</li> <li><strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</li> <li><strong>标签模板</strong>：函数参数的特殊调用</li> <li><strong>String.raw()</strong>：返回把字符串所有变量替换且对斜杠进行转义的结果</li> <li><strong>String.fromCodePoint()</strong>：返回码点对应字符</li> <li><strong>codePointAt()</strong>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li> <li><strong>normalize()</strong>：把字符的不同表示方法统一为同样形式，返回<code>新字符串</code>(<code>Unicode正规化</code>)</li> <li><strong>repeat()</strong>：把字符串重复n次，返回<code>新字符串</code></li> <li><strong>matchAll()</strong>：返回正则表达式在字符串的所有匹配</li> <li><strong>includes()</strong>：是否存在指定字符串</li> <li><strong>startsWith()</strong>：是否存在字符串头部指定字符串</li> <li><strong>endsWith()</strong>：是否存在字符串尾部指定字符串</li></ul> <h4 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h4> <p>以上扩展方法均可作用于由<strong>4个字节</strong>储存的<code>Unicode字符</code>上</p> <h4 id="模板字符串"><a href="#模板字符串" class="header-anchor">#</a> 模板字符串</h4> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'Vino'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//花括号中可以放入表达式、运算以及对象属性</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Who is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token operator">+</span><span class="token number">2</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>

	<span class="token comment">//在ES5时我们通过反斜杠(\)来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。</span>
    <span class="token comment">// es5</span>
    <span class="token keyword">var</span> msg <span class="token operator">=</span> &quot;Hi \
    man<span class="token operator">!</span>
    &quot;
    <span class="token comment">// es6</span>
    <span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;
        &lt;span&gt;hello world&lt;/span&gt;
    &lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>

	<span class="token comment">//ES6常用到的字符串方法</span>
	<span class="token comment">//1.include</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706527-46237">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    var a = 'Vino';
    console.log(`My name is ${a}`);

	//花括号中可以放入表达式、运算以及对象属性
	console.log(`Who is ${a+2}?`)

	//在ES5时我们通过反斜杠(\)来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。
    // es5
    var msg = &quot;Hi \
    man!
    &quot;
    // es6
    const template = `&lt;div&gt;
        &lt;span&gt;hello world&lt;/span&gt;
    &lt;/div&gt;`

	//ES6常用到的字符串方法
	//1.include
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706527-46237" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706527-95042">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    var a = 'Vino';
    console.log(`My name is ${a}`);

	//花括号中可以放入表达式、运算以及对象属性
	console.log(`Who is ${a+2}?`)

	//在ES5时我们通过反斜杠(\)来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。
    // es5
    var msg = &quot;Hi \
    man!
    &quot;
    // es6
    const template = `&lt;div&gt;
        &lt;span&gt;hello world&lt;/span&gt;
    &lt;/div&gt;`

	//ES6常用到的字符串方法
	//1.include
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706527-95042" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h5 id="es6常用到的字符串方法"><a href="#es6常用到的字符串方法" class="header-anchor">#</a> ES6常用到的字符串方法:</h5> <blockquote><p>1.includes:判断字符串中是否包含，返回Boolean</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706528-47086">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    let str = 'hello';
    console.log(str.includes('e'));//true
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706528-47086" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706528-5974">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    let str = 'hello';
    console.log(str.includes('e'));//true
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706528-5974" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><blockquote><p>2.repeat:操作字符串重复n次</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//hellohellohello</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706528-67157">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    let str = 'hello';
    console.log(str.repeat(3));//hellohellohello
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706528-67157" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706528-6836">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    let str = 'hello';
    console.log(str.repeat(3));//hellohellohello
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706528-6836" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h3 id="数值扩展"><a href="#数值扩展" class="header-anchor">#</a> 数值扩展</h3> <ul><li><strong>二进制表示法</strong>：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li> <li><strong>八进制表示法</strong>：<code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li> <li><strong>Number.EPSILON</strong>：数值最小精度</li> <li><strong>Number.MIN_SAFE_INTEGER</strong>：最小安全数值(<code>-2^53</code>)</li> <li><strong>Number.MAX_SAFE_INTEGER</strong>：最大安全数值(<code>2^53</code>)</li> <li><strong>Number.parseInt()</strong>：返回转换值的整数部分</li> <li><strong>Number.parseFloat()</strong>：返回转换值的浮点数部分</li> <li><strong>Number.isFinite()</strong>：是否为有限数值</li> <li><strong>Number.isNaN()</strong>：是否为NaN</li> <li><strong>Number.isInteger()</strong>：是否为整数</li> <li><strong>Number.isSafeInteger()</strong>：是否在数值安全范围内</li> <li><strong>Math.trunc()</strong>：返回数值整数部分</li> <li><strong>Math.sign()</strong>：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li> <li><strong>Math.cbrt()</strong>：返回数值立方根</li> <li><strong>Math.clz32()</strong>：返回数值的32位无符号整数形式</li> <li><strong>Math.imul()</strong>：返回两个数值相乘</li> <li><strong>Math.fround()</strong>：返回数值的32位单精度浮点数形式</li> <li><strong>Math.hypot()</strong>：返回所有数值平方和的平方根</li> <li><strong>Math.expm1()</strong>：返回<code>e^n - 1</code></li> <li><strong>Math.log1p()</strong>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li> <li><strong>Math.log10()</strong>：返回以10为底的n的对数</li> <li><strong>Math.log2()</strong>：返回以2为底的n的对数</li> <li><strong>Math.sinh()</strong>：返回n的双曲正弦</li> <li><strong>Math.cosh()</strong>：返回n的双曲余弦</li> <li><strong>Math.tanh()</strong>：返回n的双曲正切</li> <li><strong>Math.asinh()</strong>：返回n的反双曲正弦</li> <li><strong>Math.acosh()</strong>：返回n的反双曲余弦</li> <li><strong>Math.atanh()</strong>：返回n的反双曲正切</li></ul> <h3 id="对象扩展"><a href="#对象扩展" class="header-anchor">#</a> 对象扩展</h3> <ul><li><p><strong>简洁表示法</strong>：直接写入变量和函数作为对象的属性和方法(<code>{ prop, method() {} }</code>)</p></li> <li><p><strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</p></li> <li><p><strong>方法的name属性</strong>：返回方法函数名</p> <ul><li>取值函数(getter)和存值函数(setter)：<code>get/set 函数名</code>(属性的描述对象在<code>get</code>和<code>set</code>上)</li> <li>bind返回的函数：<code>bound 函数名</code></li> <li>Function构造函数返回的函数实例：<code>anonymous</code></li></ul></li> <li><p><strong>属性的可枚举性和遍历</strong>：描述对象的<code>enumerable</code></p></li> <li><p><strong>super关键字</strong>：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() {}</code>)</p></li> <li><p><strong>Object.is()</strong>：对比两值是否相等</p></li> <li><p><strong>Object.assign()</strong>：合并对象(浅拷贝)，返回原对象</p></li> <li><p><strong>Object.getPrototypeOf()</strong>：返回对象的原型对象</p></li> <li><p><strong>Object.setPrototypeOf()</strong>：设置对象的原型对象</p></li> <li><p><strong><strong>proto</strong></strong>：返回或设置对象的原型对象</p></li></ul> <h4 id="属性遍历"><a href="#属性遍历" class="header-anchor">#</a> 属性遍历</h4> <ul><li><p>描述：<code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></p></li> <li><p>遍历</p> <ul><li><code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li> <li><code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性的键组成的数组</li> <li><code>Object.getOwnPropertyNames()</code>：返回对象<code>自身可继承可枚举非枚举</code>属性的键组成的数组</li> <li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>Symbol</code>属性的键组成的数组</li> <li><code>Reflect.ownKeys()</code>：返回对象<code>自身可继承可枚举非枚举Symbol</code>属性的键组成的数组</li></ul></li> <li><p>规则</p> <ul><li>首先遍历所有数值键，按照数值升序排列</li> <li>其次遍历所有字符串键，按照加入时间升序排列</li> <li>最后遍历所有Symbol键，按照加入时间升序排列</li></ul></li></ul> <h3 id="数组扩展"><a href="#数组扩展" class="header-anchor">#</a> 数组扩展</h3> <ul><li><p><strong>扩展运算符(...)</strong>：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</p></li> <li><p><strong>Array.from()</strong>：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组</p> <ul><li>类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li> <li>可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ul></li> <li><p><strong>Array.of()</strong>：转换一组值为真正数组，返回新数组</p></li> <li><p><strong>copyWithin()</strong>：把指定位置的成员复制到其他位置，返回原数组</p></li> <li><p><strong>find()</strong>：返回第一个符合条件的成员</p></li> <li><p><strong>findIndex()</strong>：返回第一个符合条件的成员索引值</p></li> <li><p><strong>fill()</strong>：根据指定值填充整个数组，返回原数组</p></li> <li><p><strong>keys()</strong>：返回以索引值为遍历器的对象</p></li> <li><p><strong>values()</strong>：返回以属性值为遍历器的对象</p></li> <li><p><strong>entries()</strong>：返回以索引值和属性值为遍历器的对象</p></li> <li><p><strong>数组空位</strong>：ES6明确将数组空位转为<code>undefined</code>(<code>空位处理规不一，建议避免出现</code>)</p></li></ul> <h4 id="扩展应用"><a href="#扩展应用" class="header-anchor">#</a> 扩展应用</h4> <ul><li>克隆数组：<code>const arr = [...arr1]</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//舍弃for i 循环</span>
<span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">const</span> arrCopy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> i<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	arrCopy<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//cool !</span>
<span class="token keyword">const</span> arrCopy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706528-91065">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="//舍弃for i 循环
const len = arr.length;
const arrCopy = [];
let i;
for(i = 0;i &lt; len;i++){
	arrCopy[i] = arr[i];
};

//cool !
const arrCopy = [...arr];
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706528-91065" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706528-88820">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="//舍弃for i 循环
const len = arr.length;
const arrCopy = [];
let i;
for(i = 0;i &lt; len;i++){
	arrCopy[i] = arr[i];
};

//cool !
const arrCopy = [...arr];
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706528-88820" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><ul><li>合并数组：<code>const arr = [...arr1, ...arr2]</code></li> <li>拼接数组：<code>arr.push(...arr1)</code></li> <li>代替apply：<code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li> <li>转换字符串为数组：<code>[...&quot;hello&quot;]</code></li> <li>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></li> <li>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></li> <li>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></li> <li>计算Unicode字符长度：<code>Array.from(&quot;hello&quot;).length</code> =&gt; <code>[...&quot;hello&quot;].length</code></li></ul> <h5 id="重点难点-2"><a href="#重点难点-2" class="header-anchor">#</a> 重点难点</h5> <p>使用<code>keys()</code>、<code>values()</code>、<code>entries()</code>返回的遍历器对象，可用<code>for-of</code>自动遍历或<code>next()</code>手动遍历</p> <h3 id="函数扩展"><a href="#函数扩展" class="header-anchor">#</a> 函数扩展</h3> <ul><li><p><strong>参数默认值</strong>：为函数参数指定默认值</p> <ul><li>形式：<code>function Func(x = 1, y = 2) {}</code></li> <li>参数赋值：惰性求值(函数调用后才求值)</li> <li>参数位置：尾参数</li> <li>参数作用域：函数作用域</li> <li>声明方式：默认声明，不能用<code>const</code>或<code>let</code>再次声明</li> <li>length：返回没有指定默认值的参数个数</li> <li>与解构赋值默认值结合：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li> <li>应用
<ul><li>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) {}</code></li> <li>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></li></ul></li></ul></li> <li><p><strong>rest/spread参数(...)</strong>：返回函数多余参数</p> <ul><li>形式：以数组的形式存在，之后不能再有其他参数</li> <li>作用：代替<code>Arguments对象</code></li> <li>length：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li></ul></li> <li><p><strong>严格模式</strong>：在严格条件下运行JS</p> <ul><li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li></ul></li> <li><p><strong>name属性</strong>：返回函数的函数名</p> <ul><li>将匿名函数赋值给变量：<code>空字符串</code>(<strong>ES5</strong>)、<code>变量名</code>(<strong>ES6</strong>)</li> <li>将具名函数赋值给变量：<code>函数名</code>(<strong>ES5和ES6</strong>)</li> <li>bind返回的函数：<code>bound 函数名</code>(<strong>ES5和ES6</strong>)</li> <li>Function构造函数返回的函数实例：<code>anonymous</code>(<strong>ES5和ES6</strong>)</li></ul></li> <li><p><strong>箭头函数(=&gt;)</strong>：函数简写</p> <ul><li>无参数：<code>() =&gt; {}</code></li> <li>单个参数：<code>x =&gt; {}</code></li> <li>多个参数：<code>(x, y) =&gt; {}</code></li> <li>解构参数：<code>({x, y}) =&gt; {}</code></li> <li>嵌套使用：部署管道机制</li> <li>this指向固定化
<ul><li>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></li> <li>因为没有<code>this</code>，因此不能用作构造函数</li></ul></li></ul></li> <li><p><strong>尾调用优化</strong>：只保留内层函数的调用帧</p> <ul><li><p>尾调用</p> <ul><li>定义：某个函数的最后一步是调用另一个函数</li> <li>形式：<code>function f(x) { return g(x); }</code></li></ul></li> <li><p>尾递归</p> <ul><li>定义：函数尾调用自身</li> <li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li> <li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul></li></ul> <h4 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数 =&gt;</h4> <p>和普通函数相比，箭头函数的特点：</p> <blockquote><p>1.不绑定this。函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象；
2.可让this指向固定化，这种特性很有利于封装回调函数
3.不可以当做构造函数，也就是说不可以使用new命令，否则会报错；
4.不可以使用yield命令，因此箭头函数不能用作Generator函数；
5.箭头函数中不可以使用arguments对象，如果要用，可以用Rest参数代替；
6.没有原型属性
7.返回对象时必须在对象外面加上括号</p></blockquote> <p><strong>this指向的固定化</strong>，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致<strong>内部的this就是外层代码块的this</strong>。正是因为它没有this，所以也就不能用作构造函数</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">//1.</span>
    <span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> a<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//等价于：</span>
	<span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token parameter">a</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">;</span>

	<span class="token comment">//2.</span>
	<span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">persion</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//等价于：</span>
	<span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token parameter">a</span> <span class="token operator">=&gt;</span> <span class="token parameter">b</span> <span class="token operator">=&gt;</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>

	<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//3.</span>
	<span class="token keyword">const</span> <span class="token function-variable function">full</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>first<span class="token punctuation">,</span>last<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> first <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last<span class="token punctuation">;</span>
	<span class="token comment">//等同于：</span>
	<span class="token keyword">function</span> <span class="token function">full</span><span class="token punctuation">(</span><span class="token parameter">person</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> person<span class="token punctuation">.</span>first <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>last<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token number">4.</span>
	<span class="token comment">// ES5</span>
    <span class="token keyword">var</span> total <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ES6</span>
    <span class="token keyword">var</span> total <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706529-10270">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    //1.
    var fn = function(a){
		return a;
	};
	//等价于：
	var fn = a =&gt; a;

	//2.
	var fn = function(a){
		return function persion(b){
			return a+b;
		}
	};
	//等价于：
	var fn = a =&gt; b =&gt; a+b;

	fn(2)(3);

	//3.
	const full = ({first,last}) =&gt; first + ' ' + last;
	//等同于：
	function full(person){
		return person.first + ' ' + person.last;
	};

	4.
	// ES5
    var total = values.reduce(function (a, b) {
        return a + b;
    }, 0);
    // ES6
    var total = values.reduce((a, b) =&gt; a + b, 0);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706529-10270" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706529-38240">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    //1.
    var fn = function(a){
		return a;
	};
	//等价于：
	var fn = a =&gt; a;

	//2.
	var fn = function(a){
		return function persion(b){
			return a+b;
		}
	};
	//等价于：
	var fn = a =&gt; b =&gt; a+b;

	fn(2)(3);

	//3.
	const full = ({first,last}) =&gt; first + ' ' + last;
	//等同于：
	function full(person){
		return person.first + ' ' + person.last;
	};

	4.
	// ES5
    var total = values.reduce(function (a, b) {
        return a + b;
    }, 0);
    // ES6
    var total = values.reduce((a, b) =&gt; a + b, 0);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706529-38240" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><p>立即执行函数改写为箭头函数的形式：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ES6 箭头函数！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-17385">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    (() =&gt; {
		console.log('ES6 箭头函数！');
	})()
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-17385" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706529-11063">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    (() =&gt; {
		console.log('ES6 箭头函数！');
	})()
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706529-11063" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><p>在箭头函数中，获取不到arguments：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//此时会报错，arguments is not defined</span>

	<span class="token comment">// good</span>
	<span class="token keyword">function</span> <span class="token function">concatenateAll</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token keyword">return</span> args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-96561">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    const fn = () =&gt; console.log(arguments.length);
    fn();
    //此时会报错，arguments is not defined

	// good
	function concatenateAll(...args) {
	    return args.join('');
	}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-96561" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-42353">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    const fn = () =&gt; console.log(arguments.length);
    fn();
    //此时会报错，arguments is not defined

	// good
	function concatenateAll(...args) {
	    return args.join('');
	}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-42353" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><p>传参时，设置默认值：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// low</span>
	<span class="token keyword">function</span> <span class="token function">handleThings</span><span class="token punctuation">(</span><span class="token parameter">opts</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    opts <span class="token operator">=</span> opts <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// good</span>
	<span class="token keyword">function</span> <span class="token function">handleThings</span><span class="token punctuation">(</span><span class="token parameter">opts <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token comment">// ...</span>
	<span class="token punctuation">}</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-13019">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    // low
	function handleThings(opts) {
	    opts = opts || {};
	}
	
	// good
	function handleThings(opts = {}) {
	    // ...
	}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-13019" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-1999">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    // low
	function handleThings(opts) {
	    opts = opts || {};
	}
	
	// good
	function handleThings(opts = {}) {
	    // ...
	}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-1999" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><p>箭头函数无法使用 call（）或 apply（）来改变其运行的作用域。</p> <div class="language-js extra-class"><pre class="language-js"><code>    window<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	　　 color<span class="token operator">:</span> <span class="token string">&quot;blue&quot;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> <span class="token function-variable function">sayColor</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	　　<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">sayColor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//red</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-58948">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    window.color = &quot;red&quot;;
	let color = &quot;green&quot;;
	let obj = {
	　　 color: &quot;blue&quot;
	};
	let sayColor = () =&gt; {
	　　return this.color;
	};
	sayColor.apply(obj);//red
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-58948" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-89160">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    window.color = &quot;red&quot;;
	let color = &quot;green&quot;;
	let obj = {
	　　 color: &quot;blue&quot;
	};
	let sayColor = () =&gt; {
	　　return this.color;
	};
	sayColor.apply(obj);//red
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-89160" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><blockquote><p><strong>注意：</strong> 箭头函数返回对象时，需要注意。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// undefined!</span>
	
	<span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// SyntaxError: function statement requires a name（未定义函数语句）</span>
	<span class="token comment">// 这是因为花括号（即 {} ）里面的代码被解析为序列语句了</span>
	<span class="token comment">//（例如， foo 被认为是一个标签, 而非文字表达式的组成部分）。</span>
	
    <span class="token comment">// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:</span>
	
	<span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-90729">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    var func = () =&gt; { foo: 1 };
	// undefined!
	
	var func = () =&gt; { foo: function() {} };
	// SyntaxError: function statement requires a name（未定义函数语句）
	// 这是因为花括号（即 {} ）里面的代码被解析为序列语句了
	//（例如， foo 被认为是一个标签, 而非文字表达式的组成部分）。
	
    // 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:
	
	var func = () =&gt; ({ foo: 1 });
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-90729" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-51157">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    var func = () =&gt; { foo: 1 };
	// undefined!
	
	var func = () =&gt; { foo: function() {} };
	// SyntaxError: function statement requires a name（未定义函数语句）
	// 这是因为花括号（即 {} ）里面的代码被解析为序列语句了
	//（例如， foo 被认为是一个标签, 而非文字表达式的组成部分）。
	
    // 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:
	
	var func = () =&gt; ({ foo: 1 });
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-51157" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h3 id="正则扩展"><a href="#正则扩展" class="header-anchor">#</a> 正则扩展</h3> <ul><li><p><strong>变更RegExp构造函数入参</strong>：允许首参数为<code>正则对象</code>，尾参数为<code>正则修饰符</code>(<code>返回的正则表达式会忽略原正则表达式的修饰符</code>)</p></li> <li><p><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></p></li> <li><p><strong>u修饰符</strong>：Unicode模式修饰符，正确处理大于<code>\uFFFF</code>的<code>Unicode字符</code></p> <ul><li><code>点字符</code>(.)</li> <li><code>Unicode表示法</code></li> <li><code>量词</code></li> <li><code>预定义模式</code></li> <li><code>i修饰符</code></li> <li><code>转义</code></li></ul></li> <li><p><strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</p></li> <li><p><strong>unicode</strong>：是否设置<code>u修饰符</code></p></li> <li><p><strong>sticky</strong>：是否设置<code>y修饰符</code></p></li> <li><p><strong>flags</strong>：正则表达式的修饰符</p></li></ul> <h4 id="重点难点-3"><a href="#重点难点-3" class="header-anchor">#</a> 重点难点</h4> <ul><li><code>y修饰符</code>隐含头部匹配标志^</li> <li>单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配，必须与<code>g修饰符</code>联用才能返回所有匹配</li></ul> <h3 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h3> <ul><li><p>定义：独一无二的值</p></li> <li><p>声明：<code>const set = Symbol(str)</code></p></li> <li><p>入参：字符串(<code>可选</code>)</p></li> <li><p>方法</p> <ul><li><strong>Symbol()</strong>：创建以参数作为描述的<code>Symbol值</code>(<code>不登记在全局环境</code>)</li> <li><strong>Symbol.for()</strong>：创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(<code>先搜索后创建，登记在全局环境</code>)</li> <li><strong>Symbol.keyFor()</strong>：返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li> <li><strong>Object.getOwnPropertySymbols()</strong>：返回对象中所有用作属性名的<code>Symbol值</code>的数组</li></ul></li> <li><p>内置</p> <ul><li><strong>Symbol.hasInstance</strong>：指向一个内部方法，当其他对象使用<code>instanceof运算符</code>判断是否为此对象的实例时会调用此方法</li> <li><strong>Symbol.isConcatSpreadable</strong>：指向一个布尔值，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li> <li><strong>Symbol.species</strong>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li> <li><strong>Symbol.match</strong>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li> <li><strong>Symbol.replace</strong>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li> <li><strong>Symbol.search</strong>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li> <li><strong>Symbol.split</strong>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li> <li><strong>Symbol.iterator</strong>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</li> <li><strong>Symbol.toPrimitive</strong>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li> <li><strong>Symbol.toStringTag</strong>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li> <li><strong>Symbol.unscopables</strong>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</li></ul></li></ul> <h4 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h4> <ul><li>Undefined</li> <li>Null</li> <li>String</li> <li>Number</li> <li>Boolean</li> <li>Object(包含Array、Function、Date、RegExp、Error)</li> <li>Symbol</li></ul> <h4 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h4> <ul><li>唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li> <li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li> <li>遍历属性名：无法通过<code>for-in</code>、<code>for-of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，只能通过<code>Object.getOwnPropertySymbols</code>返回</li> <li>启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(<code>window</code>和<code>global</code>)，使用<code>Symbol.for()</code>来模拟全局的<code>Singleton模式</code></li></ul> <h4 id="重点难点-4"><a href="#重点难点-4" class="header-anchor">#</a> 重点难点</h4> <ul><li><code>Symbol()</code>生成一个原始类型的值不是对象，因此<code>Symbol()</code>前<strong>不能</strong>使用<code>new命令</code></li> <li><code>Symbol()</code>参数表示对当前<code>Symbol值</code>的描述，相同参数的<code>Symbol()</code>返回值不相等</li> <li><code>Symbol值</code>不能与其他类型的值进行运算</li> <li><code>Symbol值</code>可通过<code>String()</code>或<code>toString()</code>显式转为字符串</li> <li><code>Symbol值</code>作为对象属性名时，此属性是公开属性，但不是私有属性</li> <li><code>Symbol值</code>作为对象属性名时，只能用方括号运算符(<code>[]</code>)读取，不能用点运算符(.)读取</li> <li><code>Symbol值</code>作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义<code>非私有但又只用于内部</code>的方法</li></ul> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <h4 id="set-2"><a href="#set-2" class="header-anchor">#</a> Set</h4> <ul><li><p>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</p></li> <li><p>声明：<code>const set = new Set(arr)</code></p></li> <li><p>入参：具有<code>Iterator接口</code>的数据结构</p></li> <li><p>属性</p> <ul><li><strong>constructor</strong>：构造函数，返回Set</li> <li><strong>size</strong>：返回实例成员总数</li></ul></li> <li><p>方法</p> <ul><li><strong>add()</strong>：添加值，返回实例</li> <li><strong>delete()</strong>：删除值，返回布尔值</li> <li><strong>has()</strong>：检查值，返回布尔值</li> <li><strong>clear()</strong>：清除所有成员</li> <li><strong>keys()</strong>：返回以属性值为遍历器的对象</li> <li><strong>values()</strong>：返回以属性值为遍历器的对象</li> <li><strong>entries()</strong>：返回以属性值和属性值为遍历器的对象</li> <li><strong>forEach()</strong>：使用回调函数遍历每个成员</li></ul></li></ul> <p>就是对数组的一种包装,本质上还是一个map，因此会有以下几种遍历方法：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">var</span> imgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//根据KEY遍历</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> imgs<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//a</span>
	<span class="token comment">//b</span>
	<span class="token comment">//c</span>
	
	<span class="token comment">//根据VALUE遍历</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> imgs<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//a</span>
	<span class="token comment">//b</span>
	<span class="token comment">//c</span>
	
	<span class="token comment">//根据KEY-VALUE遍历</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> imgs<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//['a','a']</span>
	<span class="token comment">//['b','b']</span>
	<span class="token comment">//['c','c']</span>
	
	<span class="token comment">//普通for...of循环(for...of跟for-in的区别很明显，就是直接取值，而不再取下标了)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> imgs<span class="token punctuation">)</span><span class="token punctuation">{</span>
	     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//a</span>
	<span class="token comment">//b</span>
	<span class="token comment">//c</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-71611">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    var imgs = new Set(['a','b','c']);
	//根据KEY遍历
	for(let item of imgs.keys()){
	     console.log(item);
	}
	//a
	//b
	//c
	
	//根据VALUE遍历
	for(let item of imgs.values()){
	     console.log(item);
	}
	//a
	//b
	//c
	
	//根据KEY-VALUE遍历
	for(let item of imgs.entries()){
	     console.log(item);
	}
	//['a','a']
	//['b','b']
	//['c','c']
	
	//普通for...of循环(for...of跟for-in的区别很明显，就是直接取值，而不再取下标了)
	for(let item of imgs){
	     console.log(item);
	}
	//a
	//b
	//c
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-71611" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706530-30915">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    var imgs = new Set(['a','b','c']);
	//根据KEY遍历
	for(let item of imgs.keys()){
	     console.log(item);
	}
	//a
	//b
	//c
	
	//根据VALUE遍历
	for(let item of imgs.values()){
	     console.log(item);
	}
	//a
	//b
	//c
	
	//根据KEY-VALUE遍历
	for(let item of imgs.entries()){
	     console.log(item);
	}
	//['a','a']
	//['b','b']
	//['c','c']
	
	//普通for...of循环(for...of跟for-in的区别很明显，就是直接取值，而不再取下标了)
	for(let item of imgs){
	     console.log(item);
	}
	//a
	//b
	//c
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706530-30915" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><p>SET集合没有提供下标方式的访问，因此只能使用for来遍历。</p> <h5 id="应用场景-3"><a href="#应用场景-3" class="header-anchor">#</a> 应用场景</h5> <ul><li><p>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></p></li> <li><p>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></p></li> <li><p>集合数组</p> <ul><li>声明：<code>const a = new Set(arr1)、const b = new Set(arr2)</code></li> <li>并集：<code>new Set([...a, ...b])</code></li> <li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li> <li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li></ul></li> <li><p>映射集合</p> <ul><li>声明：<code>let set = new Set(arr)</code></li> <li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul></li></ul> <h5 id="重点难点-5"><a href="#重点难点-5" class="header-anchor">#</a> 重点难点</h5> <ul><li>遍历顺序：插入顺序</li> <li>没有键只有值，可认为键和值两值相等</li> <li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li> <li>添加相同的对象时，会认为是不同的对象</li> <li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li> <li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li></ul> <h4 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h4> <ul><li><p>定义：和Set结构类似，成员值只能是对象</p></li> <li><p>声明：<code>const set = new WeakSet(arr)</code></p></li> <li><p>入参：具有<code>Iterator接口</code>的数据结构</p></li> <li><p>属性</p> <ul><li><strong>constructor</strong>：构造函数，返回WeakSet</li></ul></li> <li><p>方法</p> <ul><li><strong>add()</strong>：添加值，返回实例</li> <li><strong>delete()</strong>：删除值，返回布尔值</li> <li><strong>has()</strong>：检查值，返回布尔值</li></ul></li></ul> <h5 id="应用场景-4"><a href="#应用场景-4" class="header-anchor">#</a> 应用场景</h5> <ul><li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li> <li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消</li></ul> <h5 id="重点难点-6"><a href="#重点难点-6" class="header-anchor">#</a> 重点难点</h5> <ul><li>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li> <li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li> <li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li></ul> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <h4 id="map-2"><a href="#map-2" class="header-anchor">#</a> Map</h4> <ul><li><p>定义：类似于对象的数据结构，成员键可以是任何类型的值</p></li> <li><p>声明：<code>const set = new Map(arr)</code></p></li> <li><p>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</p></li> <li><p>属性</p> <ul><li><strong>constructor</strong>：构造函数，返回Map</li> <li><strong>size</strong>：返回实例成员总数</li></ul></li> <li><p>方法</p> <ul><li><strong>get()</strong>：返回键值对</li> <li><strong>set()</strong>：添加键值对，返回实例</li> <li><strong>delete()</strong>：删除键值对，返回布尔值</li> <li><strong>has()</strong>：检查键值对，返回布尔值</li> <li><strong>clear()</strong>：清除所有成员</li> <li><strong>keys()</strong>：返回以键为遍历器的对象</li> <li><strong>values()</strong>：返回以值为遍历器的对象</li> <li><strong>entries()</strong>：返回以键和值为遍历器的对象</li> <li><strong>forEach()</strong>：使用回调函数遍历每个成员</li></ul></li></ul> <p>Map对象就是简单的键值对映射。其中的键和值可以使任意值。（对象的键只能为字符串）</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 遍历key值</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 遍历value值</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 遍历key和value值</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706531-98337">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    let map = new Map(arr);
	// 遍历key值
	for (let key of map.keys()) {
	    console.log(key);
	};
	// 遍历value值
	for (let value of map.values()) {
	    console.log(value);
	};
	// 遍历key和value值
	for (let item of map.entries()) {
	    console.log(item[0], item[1]);
	};
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706531-98337" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706531-68503">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="    let map = new Map(arr);
	// 遍历key值
	for (let key of map.keys()) {
	    console.log(key);
	};
	// 遍历value值
	for (let value of map.values()) {
	    console.log(value);
	};
	// 遍历key和value值
	for (let item of map.entries()) {
	    console.log(item[0], item[1]);
	};
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706531-68503" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h5 id="重点难点-7"><a href="#重点难点-7" class="header-anchor">#</a> 重点难点</h5> <ul><li>遍历顺序：插入顺序</li> <li>对同一个键多次赋值，后面的值将覆盖前面的值</li> <li>对同一个对象的引用，被视为一个键</li> <li>对同样值的两个实例，被视为两个键</li> <li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li> <li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li> <li><code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li></ul> <h4 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h4> <ul><li><p>定义：和Map结构类似，成员键只能是对象</p></li> <li><p>声明：<code>const set = new WeakMap(arr)</code></p></li> <li><p>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</p></li> <li><p>属性</p> <ul><li><strong>constructor</strong>：构造函数，返回WeakMap</li></ul></li> <li><p>方法</p> <ul><li><strong>get()</strong>：返回键值对</li> <li><strong>set()</strong>：添加键值对，返回实例</li> <li><strong>delete()</strong>：删除键值对，返回布尔值</li> <li><strong>has()</strong>：检查键值对，返回布尔值</li></ul></li></ul> <h5 id="应用场景-5"><a href="#应用场景-5" class="header-anchor">#</a> 应用场景</h5> <ul><li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li> <li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul> <h5 id="重点难点-8"><a href="#重点难点-8" class="header-anchor">#</a> 重点难点</h5> <ul><li>成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li> <li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li> <li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li> <li>一旦不再需要，成员会自动消失，不用手动删除引用</li> <li>弱引用的<code>只是键而不是值</code>，值依然是正常引用</li> <li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul> <h3 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h3> <ul><li><p>定义：修改某些操作的默认行为</p></li> <li><p>声明：<code>const proxy = new Proxy(target, handler)</code></p></li> <li><p>入参</p> <ul><li><strong>target</strong>：拦截的目标对象</li> <li><strong>handler</strong>：定制拦截行为</li></ul></li> <li><p>方法</p> <ul><li><strong>Proxy.revocable()</strong>：返回可取消的Proxy实例(返回<code>{ proxy, revoke }</code>，通过revoke()取消代理)</li></ul></li> <li><p>拦截方式</p> <ul><li><strong>get()</strong>：拦截对象属性读取</li> <li><strong>set()</strong>：拦截对象属性设置，返回布尔值</li> <li><strong>has()</strong>：拦截对象属性检查<code>k in obj</code>，返回布尔值</li> <li><strong>deleteProperty()</strong>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</li> <li><strong>defineProperty()</strong>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</li> <li><strong>ownKeys()</strong>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li> <li><strong>getOwnPropertyDescriptor()</strong>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li> <li><strong>getPrototypeOf()</strong>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、	<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li> <li><strong>setPrototypeOf()</strong>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔值</li> <li><strong>isExtensible()</strong>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔值</li> <li><strong>preventExtensions()</strong>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔值</li> <li><strong>apply()</strong>：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li> <li><strong>construct()</strong>：拦截Proxy实例作为构造函数调用<code>new proxy()</code></li></ul></li></ul> <h4 id="应用场景-6"><a href="#应用场景-6" class="header-anchor">#</a> 应用场景</h4> <ul><li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li> <li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li> <li><code>set()</code>：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li> <li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li> <li><code>deleteProperty()</code>：保护内部属性不被删除</li> <li><code>defineProperty()</code>：阻止属性被外部定义</li> <li><code>ownKeys()</code>：保护内部属性不被遍历</li></ul> <h4 id="重点难点-9"><a href="#重点难点-9" class="header-anchor">#</a> 重点难点</h4> <ul><li>要使<code>Proxy</code>起作用，必须针对<strong>实例</strong>进行操作，而不是针对<strong>目标对象</strong>进行操作</li> <li>没有设置任何拦截时，等同于<strong>直接通向原对象</strong></li> <li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li> <li>代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li></ul> <h3 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h3> <ul><li>定义：保持<code>Object方法</code>的默认行为</li> <li>方法
<ul><li><strong>get()</strong>：返回对象属性</li> <li><strong>set()</strong>：设置对象属性，返回布尔值</li> <li><strong>has()</strong>：检查对象属性，返回布尔值</li> <li><strong>deleteProperty()</strong>：删除对象属性，返回布尔值</li> <li><strong>defineProperty()</strong>：定义对象属性，返回布尔值</li> <li><strong>ownKeys()</strong>：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li> <li><strong>getOwnPropertyDescriptor()</strong>：返回对象属性描述，返回对象</li> <li><strong>getPrototypeOf()</strong>：返回对象原型，返回对象</li> <li><strong>setPrototypeOf()</strong>：设置对象原型，返回布尔值</li> <li><strong>isExtensible()</strong>：返回对象是否可扩展，返回布尔值</li> <li><strong>preventExtensions()</strong>：设置对象不可扩展，返回布尔值</li> <li><strong>apply()</strong>：绑定this后执行指定函数</li> <li><strong>construct()</strong>：调用构造函数创建实例</li></ul></li></ul> <h4 id="设计目的"><a href="#设计目的" class="header-anchor">#</a> 设计目的</h4> <ul><li>将<code>Object</code>属于<code>语言内部的方法</code>放到<code>Reflect</code>上</li> <li>将某些Object方法报错情况改成返回<code>false</code></li> <li>让<code>Object操作</code>变成<code>函数行为</code></li> <li><code>Proxy</code>与<code>Reflect</code>相辅相成</li></ul> <h4 id="废弃方法"><a href="#废弃方法" class="header-anchor">#</a> 废弃方法</h4> <ul><li><code>Object.defineProperty()</code> =&gt; <code>Reflect.defineProperty()</code></li> <li><code>Object.getOwnPropertyDescriptor()</code> =&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li></ul> <h4 id="重点难点-10"><a href="#重点难点-10" class="header-anchor">#</a> 重点难点</h4> <ul><li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li> <li><code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li></ul> <h4 id="数据绑定：观察者模式"><a href="#数据绑定：观察者模式" class="header-anchor">#</a> 数据绑定：观察者模式</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> observerQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">observe</span> <span class="token operator">=</span> <span class="token parameter">fn</span> <span class="token operator">=&gt;</span> observerQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">observable</span> <span class="token operator">=</span> <span class="token parameter">obj</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>tgt<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>tgt<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
        observerQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span> age<span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">&quot;Yajun&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>person<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>person<span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> years old</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">observe</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Joway&quot;</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706531-22617">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="const observerQueue = new Set();
const observe = fn =&gt; observerQueue.add(fn);
const observable = obj =&gt; new Proxy(obj, {
    set(tgt, key, val, receiver) {
        const result = Reflect.set(tgt, key, val, receiver);
        observerQueue.forEach(v =&gt; v());
        return result;
    }
});

const person = observable({ age: 25, name: &quot;Yajun&quot; });
const print = () =&gt; console.log(`${person.name} is ${person.age} years old`);
observe(print);
person.name = &quot;Joway&quot;;
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706531-22617" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706531-60482">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="const observerQueue = new Set();
const observe = fn =&gt; observerQueue.add(fn);
const observable = obj =&gt; new Proxy(obj, {
    set(tgt, key, val, receiver) {
        const result = Reflect.set(tgt, key, val, receiver);
        observerQueue.forEach(v =&gt; v());
        return result;
    }
});

const person = observable({ age: 25, name: &quot;Yajun&quot; });
const print = () =&gt; console.log(`${person.name} is ${person.age} years old`);
observe(print);
person.name = &quot;Joway&quot;;
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706531-60482" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h3 id="class"><a href="#class" class="header-anchor">#</a> Class</h3> <ul><li><p>定义：对一类具有共同特征的事物的抽象(<strong>构造函数语法糖</strong>)</p></li> <li><p>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</p></li> <li><p>方法和关键字</p> <ul><li><strong>constructor()</strong>：构造函数，<code>new命令</code>生成实例时自动调用</li> <li><strong>extends</strong>：继承父类</li> <li><strong>super</strong>：新建父类的<code>this</code></li> <li><strong>static</strong>：定义静态属性方法</li> <li><strong>get</strong>：取值函数，拦截属性的取值行为</li> <li><strong>set</strong>：存值函数，拦截属性的存值行为</li></ul></li> <li><p>属性</p> <ul><li><strong><strong>proto</strong></strong>：<code>构造函数的继承</code>(总是指向<code>父类</code>)</li> <li><strong><strong>proto</strong>.<strong>proto</strong></strong>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</li> <li><strong>prototype.<strong>proto</strong></strong>：<code>属性方法的继承</code>(总是指向父类的<code>prototype</code>)</li></ul></li> <li><p>静态属性：定义类完成后赋值属性，该属性<code>不会被实例继承</code>，只能通过类来调用</p></li> <li><p>静态方法：使用<code>static</code>定义方法，该方法<code>不会被实例继承</code>，只能通过类来调用(方法中的<code>this</code>指向类，而不是实例)</p></li> <li><p>继承</p> <ul><li><p>实质</p> <ul><li>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</li> <li>ES6实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></li></ul></li> <li><p>super</p> <ul><li>作为函数调用：只能在构造函数中调用<code>super()</code>，内部<code>this</code>指向继承的当前子类(<code>super()</code>调用后才可在构造函数中使用<code>this</code>)</li> <li>作为对象调用：在<code>普通方法</code>中指向<code>父类的原型对象</code>，在<code>静态方法</code>中指向<code>父类</code></li></ul></li> <li><p>显示定义：使用<code>constructor() { super(); }</code>定义继承父类，没有书写则<code>显示定义</code></p></li> <li><p>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用<code>super()</code>，否则得不到父类的<code>this</code></p> <ul><li>父类静态属性方法可被子类继承</li> <li>子类继承父类后，可从<code>super</code>上调用父类静态属性方法</li></ul></li></ul></li> <li><p>实例：类相当于<code>实例的原型</code>，所有在类中定义的属性方法都会被实例继承</p> <ul><li>显式指定属性方法：使用<code>this</code>指定到自身上(使用<code>Class.hasOwnProperty()</code>可检测到)</li> <li>隐式指定属性方法：直接声明定义在对象原型上(使用<code>Class.__proto__.hasOwnProperty()</code>可检测到)</li></ul></li> <li><p>表达式</p> <ul><li>类表达式：<code>const Class = class {}</code></li> <li>name属性：返回紧跟<code>class</code>后的类名</li> <li>属性表达式：<code>[prop]</code></li> <li>Generator方法：<code>* mothod() {}</code></li> <li>Async方法：<code>async mothod() {}</code></li></ul></li> <li><p>this指向：解构实例属性或方法时会报错</p> <ul><li>绑定this：<code>this.mothod = this.mothod.bind(this)</code></li> <li>箭头函数：<code>this.mothod = () =&gt; this.mothod()</code></li></ul></li> <li><p>属性定义位置</p> <ul><li>定义在构造函数中并使用<code>this</code>指向</li> <li>定义在<code>类最顶层</code></li></ul></li> <li><p><strong>new.target</strong>：确定构造函数是如何调用</p></li></ul> <h4 id="原生构造函数"><a href="#原生构造函数" class="header-anchor">#</a> 原生构造函数</h4> <ul><li><strong>String()</strong></li> <li><strong>Number()</strong></li> <li><strong>Boolean()</strong></li> <li><strong>Array()</strong></li> <li><strong>Object()</strong></li> <li><strong>Function()</strong></li> <li><strong>Date()</strong></li> <li><strong>RegExp()</strong></li> <li><strong>Error()</strong></li></ul> <h4 id="重点难点-11"><a href="#重点难点-11" class="header-anchor">#</a> 重点难点</h4> <ul><li>在实例上调用方法，实质是调用原型上的方法</li> <li><code>Object.assign()</code>可方便地一次向类添加多个方法(<code>Object.assign(Class.prototype, { ... })</code>)</li> <li>类内部所有定义的方法是不可枚举的(<code>non-enumerable</code>)</li> <li>构造函数默认返回实例对象(<code>this</code>)，可指定返回另一个对象</li> <li>取值函数和存值函数设置在属性的<code>Descriptor对象</code>上</li> <li>类不存在变量提升</li> <li>利用<code>new.target === Class</code>写出不能独立使用必须继承后才能使用的类</li> <li>子类继承父类后，<code>this</code>指向子类实例，通过<code>super</code>对某个属性赋值，赋值的属性会变成子类实例的属性</li> <li>使用<code>super</code>时，必须显式指定是作为函数还是作为对象使用</li> <li><code>extends</code>不仅可继承类还可继承原生的构造函数</li></ul> <h4 id="私有属性方法"><a href="#私有属性方法" class="header-anchor">#</a> 私有属性方法</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> print <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;print&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Bruce&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span>print<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> years old</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706532-70099">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="const name = Symbol(&quot;name&quot;);
const print = Symbol(&quot;print&quot;);
class Person {
    constructor(age) {
        this[name] = &quot;Bruce&quot;;
        this.age = age;
    }
    [print]() {
        console.log(`${this[name]} is ${this.age} years old`);
    }
}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706532-70099" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706532-79986">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="const name = Symbol(&quot;name&quot;);
const print = Symbol(&quot;print&quot;);
class Person {
    constructor(age) {
        this[name] = &quot;Bruce&quot;;
        this.age = age;
    }
    [print]() {
        console.log(`${this[name]} is ${this.age} years old`);
    }
}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706532-79986" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h4 id="继承混合类"><a href="#继承混合类" class="header-anchor">#</a> 继承混合类</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">CopyProperties</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> source</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> <span class="token string">&quot;constructor&quot;</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">&quot;prototype&quot;</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> desc <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">MixClass</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>mixins</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Mix</span> <span class="token punctuation">{</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">CopyProperties</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">mixin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">CopyProperties</span><span class="token punctuation">(</span>Mix<span class="token punctuation">,</span> mixin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">CopyProperties</span><span class="token punctuation">(</span><span class="token class-name">Mix</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> mixin<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Mix<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">MixClass</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> Kid<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706532-42881">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="function CopyProperties(target, source) {
    for (const key of Reflect.ownKeys(source)) {
        if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) {
            const desc = Object.getOwnPropertyDescriptor(source, key);
            Object.defineProperty(target, key, desc);
        }
    }
}
function MixClass(...mixins) {
    class Mix {
        constructor() {
            for (const mixin of mixins) {
                CopyProperties(this, new mixin());
            }
        }
    }
    for (const mixin of mixins) {
        CopyProperties(Mix, mixin);
        CopyProperties(Mix.prototype, mixin.prototype);
    }
    return Mix;
}
class Student extends MixClass(Person, Kid) {}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706532-42881" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706532-71244">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="function CopyProperties(target, source) {
    for (const key of Reflect.ownKeys(source)) {
        if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) {
            const desc = Object.getOwnPropertyDescriptor(source, key);
            Object.defineProperty(target, key, desc);
        }
    }
}
function MixClass(...mixins) {
    class Mix {
        constructor() {
            for (const mixin of mixins) {
                CopyProperties(this, new mixin());
            }
        }
    }
    for (const mixin of mixins) {
        CopyProperties(Mix, mixin);
        CopyProperties(Mix.prototype, mixin.prototype);
    }
    return Mix;
}
class Student extends MixClass(Person, Kid) {}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706532-71244" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h3 id="module"><a href="#module" class="header-anchor">#</a> Module</h3> <ul><li><p>命令</p> <ul><li><p><strong>export</strong>：规定模块对外接口</p> <ul><li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li> <li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li> <li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(<code>推荐</code>)</li> <li><strong>改名导出</strong>：<code>export { name as newName }</code></li></ul></li> <li><p><strong>import</strong>：导入模块内部功能</p> <ul><li><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li> <li><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li> <li><strong>按需导入</strong>：<code>import { age, name, sex } from &quot;person&quot;</code></li> <li><strong>改名导入</strong>：<code>import { name as newName } from &quot;person&quot;</code></li> <li><strong>自执导入</strong>：<code>import &quot;person&quot;</code></li> <li><strong>复合导入</strong>：<code>import Person, { name } from &quot;person&quot;</code></li></ul></li> <li><p><strong>复合模式</strong>：<code>export命令</code>和<code>import命令</code>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</p> <ul><li><strong>默认导入导出</strong>：<code>export { default } from &quot;person&quot;</code></li> <li><strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li> <li><strong>按需导入导出</strong>：<code>export { age, name, sex } from &quot;person&quot;</code></li> <li><strong>改名导入导出</strong>：<code>export { name as newName } from &quot;person&quot;</code></li> <li><strong>具名改默认导入导出</strong>：<code>export { name as default } from &quot;person&quot;</code></li> <li><strong>默认改具名导入导出</strong>：<code>export { default as name } from &quot;person&quot;</code></li></ul></li></ul></li> <li><p>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</p></li> <li><p>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p></li> <li><p>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</p></li></ul> <h4 id="模块方案"><a href="#模块方案" class="header-anchor">#</a> 模块方案</h4> <ul><li><strong>CommonJS</strong>：用于服务器(动态化依赖)</li> <li><strong>AMD</strong>：用于浏览器(动态化依赖)</li> <li><strong>CMD</strong>：用于浏览器(动态化依赖)</li> <li><strong>UMD</strong>：用于浏览器和服务器(动态化依赖)</li> <li><strong>ESM</strong>：用于浏览器和服务器(静态化依赖)</li></ul> <h4 id="加载方式"><a href="#加载方式" class="header-anchor">#</a> 加载方式</h4> <ul><li><p><strong>运行时加载</strong></p> <ul><li>定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(<code>全部加载</code>)</li> <li>影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</li></ul></li> <li><p><strong>编译时加载</strong></p> <ul><li>定义：直接从模块中获取需要的属性和方法进行加载(<code>按需加载</code>)</li> <li>影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(<strong>本身不是对象</strong>)，可拓展JS高级语法(<strong>宏和类型校验</strong>)</li></ul></li></ul> <h4 id="加载实现"><a href="#加载实现" class="header-anchor">#</a> 加载实现</h4> <ul><li><p><strong>传统加载</strong>：通过<code>&lt;script&gt;</code>进行同步或异步加载脚本</p> <ul><li>同步加载：<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></li> <li>Defer异步加载：<code>&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</code>(<code>顺序加载，渲染完再执行</code>)</li> <li>Async异步加载：<code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;</code>(<code>乱序加载，下载完就执行</code>)</li></ul></li> <li><p><strong>模块加载</strong>：<code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code>(<code>默认是Defer异步加载</code>)</p></li></ul> <h4 id="commonjs和esm的区别"><a href="#commonjs和esm的区别" class="header-anchor">#</a> CommonJS和ESM的区别</h4> <ul><li><p><code>CommonJS</code>输出<code>值的拷贝</code>，<code>ESM</code>输出<code>值的引用</code></p> <ul><li><code>CommonJS</code>一旦输出一个值，模块内部的变化就影响不到这个值</li> <li><code>ESM</code>是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</li></ul></li> <li><p><code>CommonJS</code>是运行时加载，<code>ESM</code>是编译时加载</p> <ul><li><code>CommonJS</code>加载模块是对象(即<code>module.exports</code>)，该对象只有在脚本运行完才会生成</li> <li><code>ESM</code>加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li></ul></li></ul> <h4 id="node加载"><a href="#node加载" class="header-anchor">#</a> Node加载</h4> <ul><li><p>背景：<code>CommonJS</code>和<code>ESM</code>互不兼容，目前解决方案是将两者分开，采用各自的加载方案</p></li> <li><p>区分：要求<code>ESM</code>采用<code>.mjs</code>后缀文件名</p> <ul><li><code>require()</code>不能加载<code>.mjs</code>文件，只有<code>import</code>命令才可加载<code>.mjs</code>文件</li> <li><code>.mjs</code>文件里不能使用<code>require()</code>，必须使用<code>import命令</code>加载文件</li></ul></li> <li><p>驱动：<code>node --experimental-modules file.mjs</code></p></li> <li><p>限制：Node的<code>import命令</code>目前只支持加载本地模块(<code>file:协议</code>)，不支持加载远程模块</p></li> <li><p>加载优先级</p> <ul><li>脚本文件省略后缀名：依次尝试加载四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li> <li>以上不存在：尝试加载<code>package.json</code>的<code>main字段</code>指定的脚本</li> <li>以上不存在：依次尝试加载名称为<code>index</code>四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li> <li>以上不存在：报错</li></ul></li> <li><p>不存在的内部变量：<code>arguments</code>、<code>exports</code>、<code>module</code>、<code>require</code>、<code>this</code>、<code>__dirname</code>、<code>__filename</code></p></li> <li><p><code>CommonJS</code>加载<code>ESM</code></p> <ul><li>不能使用<code>require()</code>，只能使用<code>import()</code></li></ul></li> <li><p>ESM加载CommonJS</p> <ul><li>自动将<code>module.exports</code>转化成<code>export default</code></li> <li><code>CommonJS</code>输出缓存机制在<code>ESM</code>加载方式下依然有效</li> <li>采用<code>import命令</code>加载<code>CommonJS模块</code>时，不允许采用<code>按需导入</code>，应使用<code>默认导入</code>或<code>整体导入</code></li></ul></li></ul> <h4 id="循环加载"><a href="#循环加载" class="header-anchor">#</a> 循环加载</h4> <ul><li><p>定义：<code>脚本A</code>的执行依赖<code>脚本B</code>，而<code>脚本A</code>的执行又依赖<code>脚本B</code></p></li> <li><p>加载原理</p> <ul><li>CommonJS：<code>require()</code>首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</li> <li>ESM：<code>import命令</code>加载变量不会被缓存，而是成为一个指向被加载模块的引用</li></ul></li> <li><p>循环加载</p> <ul><li>CommonJS：只输出已经执行的部分，还未执行的部分不会输出</li> <li>ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</li></ul></li></ul> <h4 id="重点难点-12"><a href="#重点难点-12" class="header-anchor">#</a> 重点难点</h4> <ul><li>ES6模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></li> <li>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</li> <li><code>export命令</code>输出的接口与其对应的值是<code>动态绑定关系</code>，即通过该接口可获取模块内部实时的值</li> <li><code>import命令</code>大括号里的变量名必须与被导入模块对外接口的名称相同</li> <li><code>import命令</code>输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</li> <li><code>import命令</code>命令具有提升效果，会提升到整个模块的头部，首先执行</li> <li>重复执行同一句<code>import语句</code>，只会执行一次</li> <li><code>export default</code>命令只能使用一次</li> <li><code>export default命令</code>导出的整体模块，在执行<code>import命令</code>时其后不能跟<code>大括号</code></li> <li><code>export default命令</code>本质是输出一个名为<code>default</code>的变量，后面不能跟<code>变量声明语句</code></li> <li><code>export default命令</code>本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</li> <li><code>export default命令</code>和<code>export {}命令</code>可同时存在，对应<code>复合导入</code></li> <li><code>export命令</code>和<code>import命令</code>可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</li> <li><code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用<code>对象解构赋值</code>来获取输出接口</li> <li>同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</li> <li><code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</li></ul> <h4 id="单例模式：跨模块常量"><a href="#单例模式：跨模块常量" class="header-anchor">#</a> 单例模式：跨模块常量</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 常量跨文件共享</span>
<span class="token comment">// person.js</span>
<span class="token keyword">const</span> <span class="token constant">NAME</span> <span class="token operator">=</span> <span class="token string">&quot;Bruce&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">AGE</span> <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">SEX</span> <span class="token operator">=</span> <span class="token string">&quot;male&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">AGE</span><span class="token punctuation">,</span> <span class="token constant">NAME</span><span class="token punctuation">,</span> <span class="token constant">SEX</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-37659">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// 常量跨文件共享
// person.js
const NAME = &quot;Bruce&quot;;
const AGE = 25;
const SEX = &quot;male&quot;;
export { AGE, NAME, SEX };
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-37659" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-56262">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// 常量跨文件共享
// person.js
const NAME = &quot;Bruce&quot;;
const AGE = 25;
const SEX = &quot;male&quot;;
export { AGE, NAME, SEX };
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-56262" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// file1.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">AGE</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;person&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">AGE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-14319">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// file1.js
import { AGE } from &quot;person&quot;;
console.log(AGE);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-14319" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-14588">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// file1.js
import { AGE } from &quot;person&quot;;
console.log(AGE);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-14588" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// file2.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">AGE</span><span class="token punctuation">,</span> <span class="token constant">NAME</span><span class="token punctuation">,</span> <span class="token constant">SEX</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;person&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">AGE</span><span class="token punctuation">,</span> <span class="token constant">NAME</span><span class="token punctuation">,</span> <span class="token constant">SEX</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-44779">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// file2.js
import { AGE, NAME, SEX } from &quot;person&quot;;
console.log(AGE, NAME, SEX);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-44779" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-53803">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// file2.js
import { AGE, NAME, SEX } from &quot;person&quot;;
console.log(AGE, NAME, SEX);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-53803" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h4 id="默认导入互换整体导入"><a href="#默认导入互换整体导入" class="header-anchor">#</a> 默认导入互换整体导入</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Person <span class="token keyword">from</span> <span class="token string">&quot;person&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token constant">AGE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-15112">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="import Person from &quot;person&quot;;
console.log(Person.AGE);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-15112" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-94042">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="import Person from &quot;person&quot;;
console.log(Person.AGE);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-94042" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Person <span class="token keyword">from</span> <span class="token string">&quot;person&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>default<span class="token punctuation">.</span><span class="token constant">AGE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-26065">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="import * as Person from &quot;person&quot;;
console.log(Person.default.AGE);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-26065" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-70603">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="import * as Person from &quot;person&quot;;
console.log(Person.default.AGE);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-70603" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h3 id="iterator"><a href="#iterator" class="header-anchor">#</a> Iterator</h3> <ul><li><p>定义：为各种不同的数据结构提供统一的访问机制</p></li> <li><p>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</p></li> <li><p>作用</p> <ul><li>为各种数据结构提供一个统一的简便的访问接口</li> <li>使得数据结构成员能够按某种次序排列</li> <li>ES6创造了新的遍历命令<code>for-of</code>，<code>Iterator接口</code>主要供<code>for-of</code>消费</li></ul></li> <li><p>形式：<code>for-of</code>(<code>自动去寻找Iterator接口</code>)</p></li> <li><p>数据结构</p> <ul><li>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></li> <li>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></li></ul></li> <li><p>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</p></li> <li><p>遍历器对象</p> <ul><li><strong>next()</strong>：下一步操作，返回<code>{ done, value }</code>(<code>必须部署</code>)</li> <li><strong>return()</strong>：<code>for-of</code>提前退出调用，返回<code>{ done: true }</code></li> <li><strong>throw()</strong>：不使用，配合<code>Generator函数</code>使用</li></ul></li></ul> <h4 id="forof循环"><a href="#forof循环" class="header-anchor">#</a> ForOf循环</h4> <ul><li><p>定义：调用<code>Iterator接口</code>产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</p></li> <li><p>遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(<code>可识别32位UTF-16字符</code>)</p></li> <li><p>遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></p></li> <li><p>遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</p></li> <li><p>遍历Set：<code>for-of</code>获取<code>值</code> =&gt; <code>for (const v of set)</code></p></li> <li><p>遍历Map：<code>for-of</code>获取<code>键值对</code> =&gt;  <code>for (const [k, v] of map)</code></p></li> <li><p>遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</p></li> <li><p>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code></p> <ul><li><strong>keys()</strong>：返回遍历器对象，遍历所有的键</li> <li><strong>values()</strong>：返回遍历器对象，遍历所有的值</li> <li><strong>entries()</strong>：返回遍历器对象，遍历所有的键值对</li></ul></li> <li><p>与<code>for-in</code>区别</p> <ul><li>有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</li> <li>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li> <li>提供遍历所有数据结构的统一操作接口</li></ul></li></ul> <h4 id="应用场景-7"><a href="#应用场景-7" class="header-anchor">#</a> 应用场景</h4> <ul><li>改写具有<code>Iterator接口</code>的数据结构的<code>Symbol.iterator</code></li> <li>解构赋值：对Set进行结构</li> <li>扩展运算符：将部署<code>Iterator接口</code>的数据结构转为数组</li> <li>yield*：<code>yield*</code>后跟一个可遍历的数据结构，会调用其遍历器接口</li> <li>接受数组作为参数的函数：<code>for-of</code>、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></li></ul> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h3> <ul><li><p>定义：包含异步操作结果的对象</p></li> <li><p>状态</p> <ul><li><strong>进行中</strong>：<code>pending</code></li> <li><strong>已成功</strong>：<code>resolved</code></li> <li><strong>已失败</strong>：<code>rejected</code></li></ul></li> <li><p>特点</p> <ul><li>对象的状态不受外界影响</li> <li>一旦状态改变就不会再变，任何时候都可得到这个结果</li></ul></li> <li><p>声明：<code>new Promise((resolve, reject) =&gt; {})</code></p></li> <li><p>出参</p> <ul><li><strong>resolve</strong>：将状态从<code>未完成</code>变为<code>成功</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</li> <li><strong>reject</strong>：将状态从<code>未完成</code>变为<code>失败</code>，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</li></ul></li> <li><p>方法</p> <ul><li><p><strong>then()</strong>：分别指定<code>resolved状态</code>和<code>rejected状态</code>的回调函数</p> <ul><li><strong>第一参数</strong>：状态变为<code>resolved</code>时调用</li> <li><strong>第二参数</strong>：状态变为<code>rejected</code>时调用(可选)</li></ul></li> <li><p><strong>catch()</strong>：指定发生错误时的回调函数</p></li> <li><p><strong>Promise.all()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(<code>齐变更再返回</code>)</p> <ul><li>入参：具有<code>Iterator接口</code>的数据结构</li> <li>成功：只有全部实例状态变成<code>resolved</code>，最终状态才会变成<code>resolved</code></li> <li>失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></li></ul></li> <li><p><strong>Promise.race()</strong>：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(<code>先变更先返回</code>)</p></li> <li><p><strong>Promise.resolve()</strong>：将对象转为Promise对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)</p> <ul><li><strong>Promise实例</strong>：原封不动地返回入参</li> <li><strong>Thenable对象</strong>：将此对象转为Promise对象并返回(Thenable为包含<code>then()</code>的对象，执行<code>then()</code>相当于执行此对象的<code>then()</code>)</li> <li><strong>不具有then()的对象</strong>：将此对象转为Promise对象并返回，状态为<code>resolved</code></li> <li><strong>不带参数</strong>：返回Promise对象，状态为<code>resolved</code></li></ul></li> <li><p><strong>Promise.reject()</strong>：将对象转为状态为<code>rejected</code>的Promise对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</p></li></ul></li></ul> <h4 id="应用场景-8"><a href="#应用场景-8" class="header-anchor">#</a> 应用场景</h4> <ul><li>加载图片</li> <li>AJAX转Promise对象</li></ul> <h4 id="重点难点-13"><a href="#重点难点-13" class="header-anchor">#</a> 重点难点</h4> <ul><li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li> <li>状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li> <li>一旦新建<code>Promise对象</code>就会立即执行，无法中途取消</li> <li>不设置回调函数，内部抛错不会反应到外部</li> <li>当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li> <li>实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li> <li><code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li> <li><code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li> <li><code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li> <li><code>reject()</code>的作用等同于抛出错误</li> <li>实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li> <li>实例状态的错误具有<code>冒泡</code>性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li> <li>不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li> <li>建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li> <li>没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即<code>不会有任何反应</code></li> <li>作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li> <li><code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li></ul> <h3 id="generator"><a href="#generator" class="header-anchor">#</a> Generator</h3> <ul><li><p>定义：封装多个内部状态的异步编程解决方案</p></li> <li><p>形式：调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p></li> <li><p>声明：<code>function* Func() {}</code></p></li> <li><p>方法</p> <ul><li><strong>next()</strong>：使指针移向下一个状态，返回<code>{ done, value }</code>(入参会被当作上一个<code>yield命令表达式</code>的返回值)</li> <li><strong>return()</strong>：返回指定值且终结遍历<code>Generator函数</code>，返回<code>{ done: true, value: 入参 }</code></li> <li><strong>throw()</strong>：在<code>Generator函数</code>体外抛出错误，在<code>Generator函数</code>体内捕获错误，返回自定义的<code>new Errow()</code></li></ul></li> <li><p>yield命令：声明内部状态的值(<code>return</code>声明结束返回的值)</p> <ul><li>遇到<code>yield命令</code>就暂停执行后面的操作，并将其后表达式的值作为返回对象的<code>value</code></li> <li>下次调用<code>next()</code>时，再继续往下执行直到遇到下一个<code>yield命令</code></li> <li>没有再遇到<code>yield命令</code>就一直运行到<code>Generator函数</code>结束，直到遇到<code>return语句</code>为止并将其后表达式的值作为返回对象的<code>value</code></li> <li><code>Generator函数</code>没有<code>return语句</code>则返回对象的<code>value</code>为<code>undefined</code></li></ul></li> <li><p>yield*命令：在一个<code>Generator函数</code>里执行另一个<code>Generator函数</code>(后随具有<code>Iterator接口</code>的数据结构)</p></li> <li><p>遍历：通过<code>for-of</code>自动调用<code>next()</code></p></li> <li><p>作为对象属性</p> <ul><li>全写：<code>const obj = { method: function*() {} }</code></li> <li>简写：<code>const obj = { * method() {} }</code></li></ul></li> <li><p>上下文：执行产生的<code>上下文环境</code>一旦遇到<code>yield命令</code>就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在<code>当前状态</code>，等到对它执行<code>next()</code>时，这个<code>上下文环境</code>又会重新加入调用栈，冻结的变量和对象恢复执行</p></li></ul> <h4 id="方法异同"><a href="#方法异同" class="header-anchor">#</a> 方法异同</h4> <ul><li>相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></li> <li>不同点
<ul><li><strong>next()</strong>：将<code>yield命令</code>替换成一个<code>值</code></li> <li><strong>return()</strong>：将<code>yield命令</code>替换成一个<code>return语句</code></li> <li><strong>throw()</strong>：将<code>yield命令</code>替换成一个<code>throw语句</code></li></ul></li></ul> <h4 id="应用场景-9"><a href="#应用场景-9" class="header-anchor">#</a> 应用场景</h4> <ul><li>异步操作同步化表达</li> <li>控制流管理</li> <li>为对象部署Iterator接口：把<code>Generator函数</code>赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator接口</code></li> <li>作为具有Iterator接口的数据结构</li></ul> <h4 id="重点难点-14"><a href="#重点难点-14" class="header-anchor">#</a> 重点难点</h4> <ul><li>每次调用<code>next()</code>，指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行，直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li> <li>函数内部可不用<code>yield命令</code>，但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li> <li><code>yield命令</code>是暂停执行的标记，<code>next()</code>是恢复执行的操作</li> <li><code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li> <li><code>yield命令</code>用作函数参数或放在赋值表达式的右边，可不加<code>圆括号</code></li> <li><code>yield命令</code>本身没有返回值，可认为是返回<code>undefined</code></li> <li><code>yield命令表达式</code>为惰性求值，等<code>next()</code>执行到此才求值</li> <li>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</li> <li>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</li> <li>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</li> <li>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</li> <li>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</li> <li>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</li> <li>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li> <li><code>throw()</code>抛错要被内部捕获，前提是必须<code>至少执行过一次next()</code></li> <li><code>throw()</code>被捕获以后，会附带执行下一条<code>yield命令</code></li> <li>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</li></ul> <h4 id="首次next-可传值"><a href="#首次next-可传值" class="header-anchor">#</a> 首次next()可传值</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Wrapper</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> generator <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> generator<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> print <span class="token operator">=</span> <span class="token function">Wrapper</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">First Input: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">yield</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;done&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-19282">copy success</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="function Wrapper(func) {
    return function(...args) {
        const generator = func(...args);
        generator.next();
        return generator;
    }
}
const print = Wrapper(function*() {
    console.log(`First Input: ${yield}`);
    return &quot;done&quot;;
});
print().next(&quot;hello&quot;);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-19282" data-mdic-notify-delay="2000" data-mdic-copy-fail-text="copy fail" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">copy</button></div><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1589775706533-54237">Copy successed</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="function Wrapper(func) {
    return function(...args) {
        const generator = func(...args);
        generator.next();
        return generator;
    }
}
const print = Wrapper(function*() {
    console.log(`First Input: ${yield}`);
    return &quot;done&quot;;
});
print().next(&quot;hello&quot;);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1589775706533-54237" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="Copy failed" onclick="!function(t){const e={copy:(t='',e='')=&gt;new Promise((c,o)=&gt;{const n=document.createElement('textarea'),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand('copy');document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display='block',setTimeout(()=&gt;{n.style.display='none'},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">Copy</button></div></pre></div><h2 id="es2016"><a href="#es2016" class="header-anchor">#</a> ES2016</h2> <div class="img-box"><img src="/img/javascript2.1-4" alt=""> <!----></div> <h3 id="数值扩展-2"><a href="#数值扩展-2" class="header-anchor">#</a> 数值扩展</h3> <ul><li><strong>指数运算符(</strong>)**：数值求幂(相当于<code>Math.pow()</code>)</li></ul> <h3 id="数组扩展-2"><a href="#数组扩展-2" class="header-anchor">#</a> 数组扩展</h3> <ul><li><strong>includes()</strong>：是否存在指定成员</li></ul> <h2 id="es2017"><a href="#es2017" class="header-anchor">#</a> ES2017</h2> <div class="img-box"><img src="/img/javascript2.1-5" alt=""> <!----></div> <h3 id="声明-2"><a href="#声明-2" class="header-anchor">#</a> 声明</h3> <ul><li><strong>共享内存和原子操作</strong>：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在<code>JS主线程</code>和<code>web-worker线程</code>之间共享</li></ul> <h3 id="字符串扩展-2"><a href="#字符串扩展-2" class="header-anchor">#</a> 字符串扩展</h3> <ul><li><strong>padStart()</strong>：把指定字符串填充到字符串头部，返回新字符串</li> <li><strong>padEnd()</strong>：把指定字符串填充到字符串尾部，返回新字符串</li></ul> <h3 id="对象扩展-2"><a href="#对象扩展-2" class="header-anchor">#</a> 对象扩展</h3> <ul><li><strong>Object.getOwnPropertyDescriptors()</strong>：返回对象所有自身属性(非继承属性)的描述对象</li> <li><strong>Object.values()</strong>：返回以值组成的数组</li> <li><strong>Object.entries()</strong>：返回以键和值组成的数组</li></ul> <h3 id="函数扩展-2"><a href="#函数扩展-2" class="header-anchor">#</a> 函数扩展</h3> <ul><li><strong>函数参数尾逗号</strong>：允许函数最后一个参数有尾逗号</li></ul> <h3 id="async"><a href="#async" class="header-anchor">#</a> Async</h3> <ul><li><p>定义：使异步函数以同步函数的形式书写(<code>Generator函数语法糖</code>)</p></li> <li><p>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</p></li> <li><p>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p></li> <li><p>声明</p> <ul><li>具名函数：<code>async function Func() {}</code></li> <li>函数表达式：<code>const func = async function() {}</code></li> <li>箭头函数：<code>const func = async() =&gt; {}</code></li> <li>对象方法：<code>const obj = { async func() {} }</code></li> <li>类方法：<code>class Cla { async Func() {} }</code></li></ul></li> <li><p>await命令：等待当前Promise对象状态变更完毕</p> <ul><li>正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li> <li>后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果</li></ul></li> <li><p>错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</p></li></ul> <h4 id="async对generator改进"><a href="#async对generator改进" class="header-anchor">#</a> Async对Generator改进</h4> <ul><li>内置执行器</li> <li>更好的语义</li> <li>更广的适用性</li> <li>返回值是Promise对象</li></ul> <h4 id="应用场景-10"><a href="#应用场景-10" class="header-anchor">#</a> 应用场景</h4> <ul><li>按顺序完成异步操作</li></ul> <h4 id="重点难点-15"><a href="#重点难点-15" class="header-anchor">#</a> 重点难点</h4> <ul><li><p><code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</p></li> <li><p>内部<code>return返回值</code>会成为后续<code>then()</code>的出参</p></li> <li><p>内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</p></li> <li><p>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></p></li> <li><p>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</p></li> <li><p>希望即使前一个异步操作失败也不要中断后面的异步操作</p> <ul><li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li> <li><code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul></li> <li><p><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</p></li> <li><p>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</p></li> <li><p><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</p></li> <li><p>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</p></li> <li><p>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</p></li></ul> <h2 id="es2018"><a href="#es2018" class="header-anchor">#</a> ES2018</h2> <div class="img-box"><img src="/img/javascript2.1-6" alt=""> <!----></div> <h3 id="字符串扩展-3"><a href="#字符串扩展-3" class="header-anchor">#</a> 字符串扩展</h3> <ul><li><strong>放松对标签模板里字符串转义的限制</strong>：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</li></ul> <h3 id="对象扩展-3"><a href="#对象扩展-3" class="header-anchor">#</a> 对象扩展</h3> <ul><li><strong>扩展运算符(...)</strong>：转换对象为用逗号分隔的参数序列(<code>{ ...obj }</code>，相当于<code>rest/spread参数</code>的逆运算)</li></ul> <h4 id="扩展应用-2"><a href="#扩展应用-2" class="header-anchor">#</a> 扩展应用</h4> <ul><li>克隆对象：<code>const obj = { __proto__: Object.getPrototypeOf(obj1), ...obj1 }</code></li> <li>合并对象：<code>const obj = { ...obj1, ...obj2 }</code></li> <li>转换字符串为对象：<code>{ ...&quot;hello&quot; }</code></li> <li>转换数组为对象：<code>{ ...[1, 2] }</code></li> <li>与对象解构赋值结合：<code>const { x, ...rest/spread } = { x: 1, y: 2, z: 3 }</code>(不能复制继承自原型对象的属性)</li> <li>修改现有对象部分属性：<code>const obj = { x: 1, ...{ x: 2 } }</code></li></ul> <h3 id="正则扩展-2"><a href="#正则扩展-2" class="header-anchor">#</a> 正则扩展</h3> <ul><li><p><strong>s修饰符</strong>：dotAll模式修饰符，使.匹配任意单个字符(<code>dotAll模式</code>)</p></li> <li><p><strong>dotAll</strong>：是否设置<code>s修饰符</code></p></li> <li><p><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</p></li> <li><p><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</p></li> <li><p><strong>Unicode属性转义</strong>：匹配符合<code>Unicode某种属性</code>的所有字符</p> <ul><li>正向匹配：<code>\p{PropRule}</code></li> <li>反向匹配：<code>\P{PropRule}</code></li> <li>限制：<code>\p{...}</code>和<code>\P{...}</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li></ul></li> <li><p><strong>具名组匹配</strong>：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)</p> <ul><li>形式：<code>str.exec().groups.GroupName</code></li> <li>解构赋值替换
<ul><li>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u</code></li> <li>匹配：<code>time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;)</code></li></ul></li></ul></li></ul> <h3 id="promise-2"><a href="#promise-2" class="header-anchor">#</a> Promise</h3> <ul><li><strong>finally()</strong>：指定不管最后状态如何都会执行的回调函数</li></ul> <h3 id="async-2"><a href="#async-2" class="header-anchor">#</a> Async</h3> <ul><li><strong>异步迭代器(for-wait-of)</strong>：，循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</li></ul> <h2 id="es2019"><a href="#es2019" class="header-anchor">#</a> ES2019</h2> <div class="img-box"><img src="/img/javascript2.1-7" alt=""> <!----></div> <h3 id="字符串扩展-4"><a href="#字符串扩展-4" class="header-anchor">#</a> 字符串扩展</h3> <ul><li><strong>直接输入U+2028和U+2029</strong>：字符串可直接输入<code>行分隔符</code>和<code>段分隔符</code></li> <li><strong>JSON.stringify()改造</strong>：可返回不符合UTF-8标准的字符串</li> <li><strong>trimStart()</strong>：消除字符串头部空格，返回新字符串</li> <li><strong>trimEnd()</strong>：消除字符串尾部空格，返回新字符串</li></ul> <h3 id="对象扩展-4"><a href="#对象扩展-4" class="header-anchor">#</a> 对象扩展</h3> <ul><li><strong>Object.fromEntries()</strong>：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</li></ul> <h3 id="数组扩展-3"><a href="#数组扩展-3" class="header-anchor">#</a> 数组扩展</h3> <ul><li><strong>flat()</strong>：扁平化数组，返回新数组</li> <li><strong>flatMap()</strong>：映射且扁平化数组，返回新数组(只能展开一层数组)</li></ul> <h3 id="函数扩展-3"><a href="#函数扩展-3" class="header-anchor">#</a> 函数扩展</h3> <ul><li><strong>toString()改造</strong>：返回函数原始代码(与编码一致)</li> <li><strong>catch()参数可省略</strong>：<code>catch()</code>中的参数可省略</li></ul> <h3 id="symbol-2"><a href="#symbol-2" class="header-anchor">#</a> Symbol</h3> <ul><li><strong>description</strong>：返回<code>Symbol值</code>的描述</li></ul> <h2 id="es提案"><a href="#es提案" class="header-anchor">#</a> ES提案</h2> <div class="img-box"><img src="/img/javascript2.1-8" alt=""> <!----></div> <h3 id="声明-3"><a href="#声明-3" class="header-anchor">#</a> 声明</h3> <ul><li><strong>globalThis对象</strong>：作为顶层对象，指向全局环境下的<code>this</code></li> <li><strong>do表达式</strong>：封装块级作用域的操作，返回内部最后执行表达式的值(<code>do{}</code>)</li> <li><strong>throw表达式</strong>：直接使用<code>throw new Error()</code>，无需<code>()</code>或<code>{}</code>包括</li> <li><strong>!#命令</strong>：指定脚本执行器(<code>写在文件首行</code>)</li></ul> <h3 id="数值扩展-3"><a href="#数值扩展-3" class="header-anchor">#</a> 数值扩展</h3> <ul><li><strong>数值分隔符(_)</strong>：使用<code>_</code>作为千分位分隔符(<code>增加数值的可读性</code>)</li> <li><strong>BigInt()</strong>：创建任何位数的整数(新增的数据类型，使用<code>n</code>结尾)</li></ul> <h3 id="对象扩展-5"><a href="#对象扩展-5" class="header-anchor">#</a> 对象扩展</h3> <ul><li><strong>链判断操作符(?.)</strong>：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行)</li> <li><strong>空判断操作符(??)</strong>：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</li></ul> <h3 id="函数扩展-4"><a href="#函数扩展-4" class="header-anchor">#</a> 函数扩展</h3> <ul><li><strong>函数部分执行</strong>：复用函数功能(<code>?</code>表示单个参数占位符，<code>...</code>表示多个参数占位符)</li> <li><strong>管道操作符(|&gt;)</strong>：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</li> <li><strong>绑定运算符(:😃</strong>：函数绑定(左边是对象右边是函数，取代<code>bind</code>、<code>apply</code>、<code>call</code>调用)
<ul><li>bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li> <li>apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li></ul></li></ul> <h3 id="proxy-2"><a href="#proxy-2" class="header-anchor">#</a> Proxy</h3> <ul><li><strong>Promise.try()</strong>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li></ul> <h3 id="realm"><a href="#realm" class="header-anchor">#</a> Realm</h3> <ul><li>定义：提供<code>沙箱功能</code>，允许隔离代码，防止被隔离的代码拿到全局对象</li> <li>声明：<code>new Realm().global</code></li></ul> <h3 id="class-2"><a href="#class-2" class="header-anchor">#</a> Class</h3> <ul><li><strong>静态属性</strong>：使用<strong>static</strong>定义属性，该属性<strong>不会被实例继承</strong>，只能通过类来调用</li> <li><strong>私有属性</strong>：使用 <strong>#</strong> 定义属性，该属性只能在类内部访问</li> <li><strong>私有方法</strong>：使用 <strong>#</strong> 定义方法，该方法只能在类内部访问</li> <li><strong>装饰器</strong>：使用 <strong>@</strong> 注释或修改类和类方法</li></ul> <h3 id="module-2"><a href="#module-2" class="header-anchor">#</a> Module</h3> <ul><li><p><strong>import()</strong>：动态导入(返回<code>Promise</code>)</p> <ul><li>背景：<code>import命令</code>被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li> <li>位置：可在任何地方使用</li> <li>区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li> <li>场景：按需加载、条件加载、模块路径动态化</li></ul></li> <li><p><strong>import.meta</strong>：返回脚本元信息</p></li></ul> <h3 id="async-3"><a href="#async-3" class="header-anchor">#</a> Async</h3> <ul><li><strong>顶层Await</strong>：允许在模块的顶层独立使用<code>await命令</code>(借用<code>await</code>解决模块异步加载的问题)</li></ul> <h3 id="点个star支持我一下"><a href="#点个star支持我一下" aria-hidden="true" class="header-anchor">#</a> 点个<a href="https://github.com/augustVino/augustVino.github.io" target="_blank" rel="noopener noreferrer">Star<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>支持我一下 ~</h3> <div class="gitalk-container"><div id="gitalk-container"></div></div> <svg data-v-7ad861b1="" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 49.484 28.284" class="go-to-top" style="display:none;" data-v-44049f78><g data-v-7ad861b1 transform="translate(-229 -126.358)" data-v-44049f78><rect data-v-7ad861b1 fill="currentColor" width="35" height="5" rx="2" transform="translate(229 151.107) rotate(-45)" data-v-44049f78></rect> <rect data-v-7ad861b1 fill="currentColor" width="35" height="5" rx="2" transform="translate(274.949 154.642) rotate(-135)" data-v-44049f78></rect></g></svg></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FrontEnd/Tools/1.8.html" class="prev">
        VSCode 快捷键
      </a></span> <span class="next"><a href="/FrontEnd/JavaScript/2.2.html">
        防止按钮在短时间内重复点击
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6a883236.js" defer></script><script src="/assets/js/2.9374ea52.js" defer></script><script src="/assets/js/92.d467060e.js" defer></script><script src="/assets/js/37.c1852146.js" defer></script><script src="/assets/js/40.c8e1b6f3.js" defer></script><script src="/assets/js/11.c968a7c6.js" defer></script><script src="/assets/js/10.832e2843.js" defer></script>
  </body>
</html>
